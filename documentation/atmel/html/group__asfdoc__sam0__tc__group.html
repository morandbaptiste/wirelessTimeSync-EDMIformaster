<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Atmel Radio: SAM Timer/Counter Driver (TC)</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Atmel Radio
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SAM Timer/Counter Driver (TC)</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtc__events.html">tc_events</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TC event enable/disable structure.  <a href="structtc__events.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtc__8bit__config.html">tc_8bit_config</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration struct for TC module in 8-bit size counter mode.  <a href="structtc__8bit__config.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtc__16bit__config.html">tc_16bit_config</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration struct for TC module in 16-bit size counter mode.  <a href="structtc__16bit__config.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtc__32bit__config.html">tc_32bit_config</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration struct for TC module in 32-bit size counter mode.  <a href="structtc__32bit__config.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtc__pwm__channel.html">tc_pwm_channel</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration struct for TC module in 32-bit size counter mode.  <a href="structtc__pwm__channel.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtc__config.html">tc_config</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TC configuration structure.  <a href="structtc__config.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtc__module.html">tc_module</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TC software device instance structure.  <a href="structtc__module.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#gac837f9db5df1793578c195a979c6a9d3">NUMBER_OF_COMPARE_CAPTURE_CHANNELS</a>&#160;&#160;&#160;TC3_CC8_NUM</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#ga94cdbe531468f0975311bc2ce36f5e1c">TC_INST_MAX_ID</a>&#160;&#160;&#160;7</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#ga3be501afca9dd97d2adb1959f30816a7">TC_WAVE_GENERATION_NORMAL_FREQ_MODE</a>&#160;&#160;&#160;TC_CTRLA_WAVEGEN_NFRQ</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga65ebbd3eaea3bd9cf6f81392770caae6"></a><!-- doxytag: member="asfdoc_sam0_tc_group::TC_WAVE_GENERATION_MATCH_FREQ_MODE" ref="ga65ebbd3eaea3bd9cf6f81392770caae6" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TC_WAVE_GENERATION_MATCH_FREQ_MODE</b>&#160;&#160;&#160;TC_CTRLA_WAVEGEN_MFRQ</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa7277c5eaa031dbd06159cd533346210"></a><!-- doxytag: member="asfdoc_sam0_tc_group::TC_WAVE_GENERATION_NORMAL_PWM_MODE" ref="gaa7277c5eaa031dbd06159cd533346210" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TC_WAVE_GENERATION_NORMAL_PWM_MODE</b>&#160;&#160;&#160;TC_CTRLA_WAVEGEN_NPWM</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4636ecc5d5a67c47a8b6551568c31ee6"></a><!-- doxytag: member="asfdoc_sam0_tc_group::TC_WAVE_GENERATION_MATCH_PWM_MODE" ref="ga4636ecc5d5a67c47a8b6551568c31ee6" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TC_WAVE_GENERATION_MATCH_PWM_MODE</b>&#160;&#160;&#160;TC_CTRLA_WAVEGEN_MPWM</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#ga50cb4d965dd6d607839abb71b3f034c0">TC_WAVEFORM_INVERT_CC0_MODE</a>&#160;&#160;&#160;TC_CTRLC_INVEN(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae194715d12d4faa15f1d1b8555bf5b53"></a><!-- doxytag: member="asfdoc_sam0_tc_group::TC_WAVEFORM_INVERT_CC1_MODE" ref="gae194715d12d4faa15f1d1b8555bf5b53" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TC_WAVEFORM_INVERT_CC1_MODE</b>&#160;&#160;&#160;TC_CTRLC_INVEN(2)</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9626d0792ad18533560fcd093e0308fa"></a><!-- doxytag: member="asfdoc_sam0_tc_group::tc_callback_t" ref="ga9626d0792ad18533560fcd093e0308fa" args=")(struct tc_module *const module)" -->
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>tc_callback_t</b> )(struct <a class="el" href="structtc__module.html">tc_module</a> *const module)</td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#ga7d3fb5365e46bd4efae2885bd508067f">tc_callback</a> { <br/>
&#160;&#160;<a class="el" href="group__asfdoc__sam0__tc__group.html#gga7d3fb5365e46bd4efae2885bd508067fade9a99ec0d7386cfff45671de03b8b6a">TC_CALLBACK_OVERFLOW</a>, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga7d3fb5365e46bd4efae2885bd508067fab6fb975aff8c4ace0dbece4bf825332b">TC_CALLBACK_ERROR</a>, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga7d3fb5365e46bd4efae2885bd508067fa03e7143b9984e00ad432db650abd69c6">TC_CALLBACK_CC_CHANNEL0</a>, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga7d3fb5365e46bd4efae2885bd508067fae16450d1f8ef97cc1b129524b72efdf3">TC_CALLBACK_CC_CHANNEL1</a>, 
<br/>
&#160;&#160;<a class="el" href="group__asfdoc__sam0__tc__group.html#gga7d3fb5365e46bd4efae2885bd508067faf76c479c366d3c15450245bb4ee9a856">TC_CALLBACK_N</a>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#ga01eca97dbfd588fd3ba0dcfd4792d857">tc_compare_capture_channel</a> { <a class="el" href="group__asfdoc__sam0__tc__group.html#gga01eca97dbfd588fd3ba0dcfd4792d857a5f6651d829a75778a759ce5a519b76a4">TC_COMPARE_CAPTURE_CHANNEL_0</a>, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga01eca97dbfd588fd3ba0dcfd4792d857a8fcf38e3b831977347028475b5583141">TC_COMPARE_CAPTURE_CHANNEL_1</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the compare capture channels.  <a href="group__asfdoc__sam0__tc__group.html#ga01eca97dbfd588fd3ba0dcfd4792d857">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#gae7f1302b7e3d675e471a554668b49d64">tc_wave_generation</a> { <a class="el" href="group__asfdoc__sam0__tc__group.html#ggae7f1302b7e3d675e471a554668b49d64a544e51b015f20263a9499ce28a0596e7">TC_WAVE_GENERATION_NORMAL_FREQ</a> =  TC_WAVE_GENERATION_NORMAL_FREQ_MODE, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#ggae7f1302b7e3d675e471a554668b49d64a4c9b3fe1ad9a1d2c0f5d8544c0923b9f">TC_WAVE_GENERATION_MATCH_FREQ</a> =  TC_WAVE_GENERATION_MATCH_FREQ_MODE, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#ggae7f1302b7e3d675e471a554668b49d64aad9dc196250ce8ca5a98c7e49cf0c1a9">TC_WAVE_GENERATION_NORMAL_PWM</a> =  TC_WAVE_GENERATION_NORMAL_PWM_MODE, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#ggae7f1302b7e3d675e471a554668b49d64a973273609713f828ce491f56fbf035d2">TC_WAVE_GENERATION_MATCH_PWM</a> =  TC_WAVE_GENERATION_MATCH_PWM_MODE
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TC wave generation mode enum.  <a href="group__asfdoc__sam0__tc__group.html#gae7f1302b7e3d675e471a554668b49d64">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#ga1b112627b81227c49c16b1a93e3321a0">tc_counter_size</a> { <a class="el" href="group__asfdoc__sam0__tc__group.html#gga1b112627b81227c49c16b1a93e3321a0abf2e8000eeeac2a4f259ba117d1ee934">TC_COUNTER_SIZE_8BIT</a> =  TC_CTRLA_MODE_COUNT8, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga1b112627b81227c49c16b1a93e3321a0a07c9fe9d2a5e78a9c1be46ce540adad1">TC_COUNTER_SIZE_16BIT</a> =  TC_CTRLA_MODE_COUNT16, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga1b112627b81227c49c16b1a93e3321a0a7d28e63b11a550605d003c894fe134c5">TC_COUNTER_SIZE_32BIT</a> =  TC_CTRLA_MODE_COUNT32
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies if the counter is 8-, 16-, or 32-bit.  <a href="group__asfdoc__sam0__tc__group.html#ga1b112627b81227c49c16b1a93e3321a0">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#ga204bb4814c91e62e56d9297c05280aad">tc_reload_action</a> { <a class="el" href="group__asfdoc__sam0__tc__group.html#gga204bb4814c91e62e56d9297c05280aadaea50b7d7b79cfbd72298720e0f6d51ed">TC_RELOAD_ACTION_GCLK</a> =  TC_CTRLA_PRESCSYNC_GCLK, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga204bb4814c91e62e56d9297c05280aada97857fba0947beb9110ab79d2990e559">TC_RELOAD_ACTION_PRESC</a> =  TC_CTRLA_PRESCSYNC_PRESC, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga204bb4814c91e62e56d9297c05280aadac78b7c50f80b33d5ef15a63348279f17">TC_RELOAD_ACTION_RESYNC</a> =  TC_CTRLA_PRESCSYNC_RESYNC
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TC Counter reload action enum.  <a href="group__asfdoc__sam0__tc__group.html#ga204bb4814c91e62e56d9297c05280aad">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#ga98aed17b995157e67b9322a45f0ed5f4">tc_clock_prescaler</a> { <br/>
&#160;&#160;<a class="el" href="group__asfdoc__sam0__tc__group.html#gga98aed17b995157e67b9322a45f0ed5f4abee76ee986e815120c67ff104dd77275">TC_CLOCK_PRESCALER_DIV1</a> =  TC_CTRLA_PRESCALER(0), 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga98aed17b995157e67b9322a45f0ed5f4a6326eb4305153ea58ea18ee6a74bc8f0">TC_CLOCK_PRESCALER_DIV2</a> =  TC_CTRLA_PRESCALER(1), 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga98aed17b995157e67b9322a45f0ed5f4a8c137a94b34809e544d50680c808da23">TC_CLOCK_PRESCALER_DIV4</a> =  TC_CTRLA_PRESCALER(2), 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga98aed17b995157e67b9322a45f0ed5f4a3dbb4f263ba1e940954ffe8a667bf7d1">TC_CLOCK_PRESCALER_DIV8</a> =  TC_CTRLA_PRESCALER(3), 
<br/>
&#160;&#160;<a class="el" href="group__asfdoc__sam0__tc__group.html#gga98aed17b995157e67b9322a45f0ed5f4aa0bec32bcf9a450d950f9ec9941a6c3a">TC_CLOCK_PRESCALER_DIV16</a> =  TC_CTRLA_PRESCALER(4), 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga98aed17b995157e67b9322a45f0ed5f4aea8fd1d9e795ec153e80cddc15ad501b">TC_CLOCK_PRESCALER_DIV64</a> =  TC_CTRLA_PRESCALER(5), 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga98aed17b995157e67b9322a45f0ed5f4a72552d0e6095d90da22981b7bd7a33ed">TC_CLOCK_PRESCALER_DIV256</a> =  TC_CTRLA_PRESCALER(6), 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga98aed17b995157e67b9322a45f0ed5f4af1540c54586b7cd0c5e46c60162951ec">TC_CLOCK_PRESCALER_DIV1024</a> =  TC_CTRLA_PRESCALER(7)
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TC clock prescaler values.  <a href="group__asfdoc__sam0__tc__group.html#ga98aed17b995157e67b9322a45f0ed5f4">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#ga28777c47943dfb2b5de0fd7ae14eac1f">tc_count_direction</a> { <a class="el" href="group__asfdoc__sam0__tc__group.html#gga28777c47943dfb2b5de0fd7ae14eac1faf247abdaef160b832fd09bc7597e8ca3">TC_COUNT_DIRECTION_UP</a>, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga28777c47943dfb2b5de0fd7ae14eac1fade3defd512c1bff05ce6302c2d96b014">TC_COUNT_DIRECTION_DOWN</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TC module count direction.  <a href="group__asfdoc__sam0__tc__group.html#ga28777c47943dfb2b5de0fd7ae14eac1f">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#gaf681729d6b5f963705871f7d80754166">tc_waveform_invert_output</a> { <a class="el" href="group__asfdoc__sam0__tc__group.html#ggaf681729d6b5f963705871f7d80754166a292cfce35b768eecd69f2a4320aaa96b">TC_WAVEFORM_INVERT_OUTPUT_NONE</a> =  0, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#ggaf681729d6b5f963705871f7d80754166af3ebe1706d0f442c6388619bc3d9fa58">TC_WAVEFORM_INVERT_OUTPUT_CHANNEL_0</a> =  TC_WAVEFORM_INVERT_CC0_MODE, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#ggaf681729d6b5f963705871f7d80754166a97327e36339fbad207e7150d6ba7b283">TC_WAVEFORM_INVERT_OUTPUT_CHANNEL_1</a> =  TC_WAVEFORM_INVERT_CC1_MODE
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Waveform inversion mode.  <a href="group__asfdoc__sam0__tc__group.html#gaf681729d6b5f963705871f7d80754166">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#ga4dcbf6cdb74bc3b7609ce8d16549462f">tc_event_action</a> { <br/>
&#160;&#160;<a class="el" href="group__asfdoc__sam0__tc__group.html#gga4dcbf6cdb74bc3b7609ce8d16549462fa190e10df25f3f6a6c781cc751eb3489e">TC_EVENT_ACTION_OFF</a> =  TC_EVCTRL_EVACT_OFF, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga4dcbf6cdb74bc3b7609ce8d16549462fa9696961ae81b1aba22582d8a35bdf14d">TC_EVENT_ACTION_RETRIGGER</a> =  TC_EVCTRL_EVACT_RETRIGGER, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga4dcbf6cdb74bc3b7609ce8d16549462fa07b969496782cb311ddb13cfafb36aff">TC_EVENT_ACTION_INCREMENT_COUNTER</a> =  TC_EVCTRL_EVACT_COUNT, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga4dcbf6cdb74bc3b7609ce8d16549462fac06c64382b572d0464138ae51b7876df">TC_EVENT_ACTION_START</a> =  TC_EVCTRL_EVACT_START, 
<br/>
&#160;&#160;<a class="el" href="group__asfdoc__sam0__tc__group.html#gga4dcbf6cdb74bc3b7609ce8d16549462fa4957024d607401030b128f9b775edb7d">TC_EVENT_ACTION_PPW</a> =  TC_EVCTRL_EVACT_PPW, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga4dcbf6cdb74bc3b7609ce8d16549462face22a0756d93b16a9b70511fe226a893">TC_EVENT_ACTION_PWP</a> =  TC_EVCTRL_EVACT_PWP
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Action to perform when the TC module is triggered by an event.  <a href="group__asfdoc__sam0__tc__group.html#ga4dcbf6cdb74bc3b7609ce8d16549462f">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga077a238b03327682013a0bceb4fc44b2"></a><!-- doxytag: member="asfdoc_sam0_tc_group::_tc_get_inst_index" ref="ga077a238b03327682013a0bceb4fc44b2" args="(Tc *const hw)" -->
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>_tc_get_inst_index</b> (<a class="el" href="union_tc.html">Tc</a> *const hw)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Module Status Flags</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpdd98d5e8b9a5fd30d323c8eeeab117f4"></a> TC status flags, returned by tc_get_status() and cleared by tc_clear_status(). </p>
</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#gae74e90dac05478452203a41a88853286">TC_STATUS_CHANNEL_0_MATCH</a>&#160;&#160;&#160;(1UL &lt;&lt; 0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#gaab140d8ac7858f45029fddf0fd3f4cf3">TC_STATUS_CHANNEL_1_MATCH</a>&#160;&#160;&#160;(1UL &lt;&lt; 1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#ga73bfbe04c8834ec55242bcd0b678f94e">TC_STATUS_SYNC_READY</a>&#160;&#160;&#160;(1UL &lt;&lt; 2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#gac13395d51cc03b5c43eda7654649925f">TC_STATUS_CAPTURE_OVERFLOW</a>&#160;&#160;&#160;(1UL &lt;&lt; 3)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#gada6e9a6bd144c0c2e360d1fdef944cdd">TC_STATUS_COUNT_OVERFLOW</a>&#160;&#160;&#160;(1UL &lt;&lt; 4)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Driver Initialization and Configuration</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga98c7f5c97436c2f6cff87a0261597337"></a><!-- doxytag: member="asfdoc_sam0_tc_group::tc_init" ref="ga98c7f5c97436c2f6cff87a0261597337" args="(struct tc_module *const module_inst, Tc *const hw, const struct tc_config *const config)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tc_init</b> (struct <a class="el" href="structtc__module.html">tc_module</a> *const module_inst, <a class="el" href="union_tc.html">Tc</a> *const hw, const struct <a class="el" href="structtc__config.html">tc_config</a> *const config)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Enable/Disable/Reset</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad147c1f0393a3ae0c830cec73986eddd"></a><!-- doxytag: member="asfdoc_sam0_tc_group::tc_reset" ref="gad147c1f0393a3ae0c830cec73986eddd" args="(const struct tc_module *const module_inst)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tc_reset</b> (const struct <a class="el" href="structtc__module.html">tc_module</a> *const module_inst)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Get/Set Count Value</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae7d7eb91616c2dff02886dd8cdc87f2d"></a><!-- doxytag: member="asfdoc_sam0_tc_group::tc_get_count_value" ref="gae7d7eb91616c2dff02886dd8cdc87f2d" args="(const struct tc_module *const module_inst)" -->
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>tc_get_count_value</b> (const struct <a class="el" href="structtc__module.html">tc_module</a> *const module_inst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9c81066b0b88893e127fa521f0efde2e"></a><!-- doxytag: member="asfdoc_sam0_tc_group::tc_set_count_value" ref="ga9c81066b0b88893e127fa521f0efde2e" args="(const struct tc_module *const module_inst, const uint32_t count)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tc_set_count_value</b> (const struct <a class="el" href="structtc__module.html">tc_module</a> *const module_inst, const uint32_t count)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Get Capture Set Compare</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf780bb09a00298868aa3b8e7627f92ff"></a><!-- doxytag: member="asfdoc_sam0_tc_group::tc_get_capture_value" ref="gaf780bb09a00298868aa3b8e7627f92ff" args="(const struct tc_module *const module_inst, const enum tc_compare_capture_channel channel_index)" -->
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>tc_get_capture_value</b> (const struct <a class="el" href="structtc__module.html">tc_module</a> *const module_inst, const enum <a class="el" href="group__asfdoc__sam0__tc__group.html#ga01eca97dbfd588fd3ba0dcfd4792d857">tc_compare_capture_channel</a> channel_index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga687208b24fd33a1da0cbe683adc15fa6"></a><!-- doxytag: member="asfdoc_sam0_tc_group::tc_set_compare_value" ref="ga687208b24fd33a1da0cbe683adc15fa6" args="(const struct tc_module *const module_inst, const enum tc_compare_capture_channel channel_index, const uint32_t compare_value)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tc_set_compare_value</b> (const struct <a class="el" href="structtc__module.html">tc_module</a> *const module_inst, const enum <a class="el" href="group__asfdoc__sam0__tc__group.html#ga01eca97dbfd588fd3ba0dcfd4792d857">tc_compare_capture_channel</a> channel_index, const uint32_t compare_value)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Set Top Value</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac22d633ece43bcd18f54283778471340"></a><!-- doxytag: member="asfdoc_sam0_tc_group::tc_set_top_value" ref="gac22d633ece43bcd18f54283778471340" args="(const struct tc_module *const module_inst, const uint32_t top_value)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tc_set_top_value</b> (const struct <a class="el" href="structtc__module.html">tc_module</a> *const module_inst, const uint32_t top_value)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>This driver for Atmel&reg; | SMART SAM devices provides an interface for the configuration and management of the timer modules within the device, for waveform generation and timing operations. The following driver API modes are covered by this manual:</p>
<ul>
<li>Polled APIs</li>
</ul>
<p>The following peripherals are used by this module:</p>
<ul>
<li>TC (Timer/Counter)</li>
</ul>
<p>The following devices can use this module:</p>
<ul>
<li>Atmel | SMART SAM D20/D21</li>
<li>Atmel | SMART SAM R21</li>
<li>Atmel | SMART SAM D10/D11</li>
<li>Atmel | SMART SAM L21</li>
<li>Atmel | SMART SAM DAx</li>
<li>Atmel | SMART SAM C20/C21</li>
</ul>
<p>The outline of this documentation is as follows:</p>
<ul>
<li><a class="el" href="group__asfdoc__sam0__tc__group.html#asfdoc_sam0_tc_prerequisites">Prerequisites</a></li>
<li><a class="el" href="group__asfdoc__sam0__tc__group.html#asfdoc_sam0_tc_module_overview">Module Overview</a></li>
<li><a class="el" href="group__asfdoc__sam0__tc__group.html#asfdoc_sam0_tc_special_considerations">Special Considerations</a></li>
<li><a class="el" href="group__asfdoc__sam0__tc__group.html#asfdoc_sam0_tc_extra_info">Extra Information</a></li>
<li><a class="el" href="group__asfdoc__sam0__tc__group.html#asfdoc_sam0_tc_examples">Examples</a></li>
<li><a class="el" href="group__asfdoc__sam0__tc__group.html#asfdoc_sam0_tc_api_overview">API Overview</a></li>
</ul>
<h2><a class="anchor" id="asfdoc_sam0_tc_prerequisites"></a>
Prerequisites</h2>
<p>There are no prerequisites for this module.</p>
<h2><a class="anchor" id="asfdoc_sam0_tc_module_overview"></a>
Module Overview</h2>
<p>The Timer/Counter (TC) module provides a set of timing and counting related functionality, such as the generation of periodic waveforms, the capturing of a periodic waveform's frequency/duty cycle, and software timekeeping for periodic operations. TC modules can be configured to use an 8-, 16-, or 32-bit counter size.</p>
<p>This TC module for the SAM is capable of the following functions:</p>
<ul>
<li>Generation of PWM signals</li>
<li>Generation of timestamps for events</li>
<li>General time counting</li>
<li>Waveform period capture</li>
<li>Waveform frequency capture</li>
</ul>
<p><a class="el" href="group__asfdoc__sam0__tc__group.html#asfdoc_sam0_tc_block_diagram">The diagram below</a> shows the overview of the TC module design.</p>
<p><a class="anchor" id="asfdoc_sam0_tc_block_diagram"></a> </p>
<div class="image">
<img src="overview.svg" alt="overview.svg"/>
<div class="caption">
Basic Overview of the TC Module</div></div>
 <h3><a class="anchor" id="asfdoc_sam0_tc_features"></a>
Driver Feature Macro Definition</h3>
<table class="doxtable">
<tr>
<th>Driver Feature Macro </th><th>Supported devices  </th></tr>
<tr>
<td>FEATURE_TC_DOUBLE_BUFFERED </td><td>SAML21/C20/C21  </td></tr>
<tr>
<td>FEATURE_TC_SYNCBUSY_SCHEME_VERSION_2 </td><td>SAML21/C20/C21  </td></tr>
<tr>
<td>FEATURE_TC_STAMP_PW_CAPTURE </td><td>SAML21/C20/C21  </td></tr>
<tr>
<td>FEATURE_TC_READ_SYNC </td><td>SAML21/C20/C21  </td></tr>
<tr>
<td>FEATURE_TC_IO_CAPTURE </td><td>SAML21/C20/C21  </td></tr>
<tr>
<td>FEATURE_TC_GENERATE_DMA_TRIGGER </td><td>SAML21  </td></tr>
</table>
<dl class="note"><dt><b>Note:</b></dt><dd>The specific features are only available in the driver when the selected device supports those features.</dd></dl>
<h3><a class="anchor" id="asfdoc_sam0_tc_module_overview_func_desc"></a>
Functional Description</h3>
<p>Independent of the configured counter size, each TC module can be set up in one of two different modes; capture and compare.</p>
<p>In capture mode, the counter value is stored when a configurable event occurs. This mode can be used to generate timestamps used in event capture, or it can be used for the measurement of a periodic input signal's frequency/duty cycle.</p>
<p>In compare mode, the counter value is compared against one or more of the configured channel compare values. When the counter value coincides with a compare value an action can be taken automatically by the module, such as generating an output event or toggling a pin when used for frequency or PWM signal generation.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The connection of events between modules requires the use of the SAM Event System Driver (EVENTS) to route output event of one module to the input event of another. For more information on event routing, refer to the event driver documentation.</dd></dl>
<h3><a class="anchor" id="asfdoc_sam0_tc_module_overview_tc_size"></a>
Timer/Counter Size</h3>
<p>Each timer module can be configured in one of three different counter sizes; 8-, 16-, and 32-bit. The size of the counter determines the maximum value it can count to before an overflow occurs and the count is reset back to zero. <a class="el" href="group__asfdoc__sam0__tc__group.html#asfdoc_sam0_tc_count_size_vs_top">The table below</a> shows the maximum values for each of the possible counter sizes.</p>
<p><a class="anchor" id="asfdoc_sam0_tc_count_size_vs_top"></a> </p>
<table class="doxtable">
<caption align="bottom">Timer Counter Sizes and Their Maximum Count Values</caption>
<tr>
<th>Counter size </th><th>Max. (hexadecimal) </th><th>Max. (decimal)  </th></tr>
<tr>
<td>8-bit </td><td>0xFF </td><td>255  </td></tr>
<tr>
<td>16-bit </td><td>0xFFFF </td><td>65,535  </td></tr>
<tr>
<td>32-bit </td><td>0xFFFFFFFF </td><td>4,294,967,295  </td></tr>
</table>
<p>When using the counter in 16- or 32-bit count mode, Compare Capture register 0 (CC0) is used to store the period value when running in PWM generation match mode.</p>
<p>When using 32-bit counter size, two 16-bit counters are chained together in a cascade formation. Except in SAM D10/D11, Even numbered TC modules (e.g. TC0, TC2) can be configured as 32-bit counters. The odd numbered counters will act as slaves to the even numbered masters, and will not be reconfigurable until the master timer is disabled. The pairing of timer modules for 32-bit mode is shown in <a class="el" href="group__asfdoc__sam0__tc__group.html#asfdoc_sam0_tc_module_ms_pairs">the table below</a>.</p>
<p><a class="anchor" id="asfdoc_sam0_tc_module_ms_pairs"></a> </p>
<table class="doxtable">
<caption align="bottom">TC Master and Slave Module Pairings</caption>
<tr>
<th>Master TC Module </th><th>Slave TC Module  </th></tr>
<tr>
<td>TC0 </td><td>TC1  </td></tr>
<tr>
<td>TC2 </td><td>TC3  </td></tr>
<tr>
<td>... </td><td>...  </td></tr>
<tr>
<td>TCn-1 </td><td>TCn  </td></tr>
</table>
<p>In SAMD10/D11, odd numbered TC modules (e.g. TC1) can be configured as 32-bit counters. The even numbered(e.g. TC2) counters will act as slaves to the odd numbered masters.</p>
<h3><a class="anchor" id="asfdoc_sam0_tc_module_overview_clock"></a>
Clock Settings</h3>
<h4><a class="anchor" id="asfdoc_sam0_tc_module_overview_clock_selection"></a>
Clock Selection</h4>
<p>Each TC peripheral is clocked asynchronously to the system clock by a GCLK (Generic Clock) channel. The GCLK channel connects to any of the GCLK generators. The GCLK generators are configured to use one of the available clock sources on the system such as internal oscillator, external crystals, etc. see the <a class="el" href="group__asfdoc__sam0__system__clock__group.html">Generic Clock driver</a> for more information.</p>
<h4><a class="anchor" id="asfdoc_sam0_tc_module_overview_clock_prescaler"></a>
Prescaler</h4>
<p>Each TC module in the SAM has its own individual clock prescaler, which can be used to divide the input clock frequency used in the counter. This prescaler only scales the clock used to provide clock pulses for the counter to count, and does not affect the digital register interface portion of the module, thus the timer registers will synchronize to the raw GCLK frequency input to the module.</p>
<p>As a result of this, when selecting a GCLK frequency and timer prescaler value the user application should consider both the timer resolution required and the synchronization frequency, to avoid lengthy synchronization times of the module if a very slow GCLK frequency is fed into the TC module. It is preferable to use a higher module GCLK frequency as the input to the timer, and prescale this down as much as possible to obtain a suitable counter frequency in latency-sensitive applications.</p>
<h4><a class="anchor" id="asfdoc_sam0_tc_module_overview_clock_reloading"></a>
Reloading</h4>
<p>Timer modules also contain a configurable reload action, used when a re-trigger event occurs. Examples of a re-trigger event are the counter reaching the maximum value when counting up, or when an event from the event system tells the counter to re-trigger. The reload action determines if the prescaler should be reset, and when this should happen. The counter will always be reloaded with the value it is set to start counting from. The user can choose between three different reload actions, described in <a class="el" href="group__asfdoc__sam0__tc__group.html#asfdoc_sam0_tc_module_reload_act">the table below</a>.</p>
<p><a class="anchor" id="asfdoc_sam0_tc_module_reload_act"></a> </p>
<table class="doxtable">
<caption align="bottom">TC Module Reload Actions</caption>
<tr>
<th>Reload action </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="group__asfdoc__sam0__tc__group.html#gga204bb4814c91e62e56d9297c05280aadaea50b7d7b79cfbd72298720e0f6d51ed">TC_RELOAD_ACTION_GCLK</a>  </td><td>Reload TC counter value on next GCLK cycle. Leave prescaler as-is.  </td></tr>
<tr>
<td><a class="el" href="group__asfdoc__sam0__tc__group.html#gga204bb4814c91e62e56d9297c05280aada97857fba0947beb9110ab79d2990e559">TC_RELOAD_ACTION_PRESC</a>  </td><td>Reloads TC counter value on next prescaler clock. Leave prescaler as-is.  </td></tr>
<tr>
<td><a class="el" href="group__asfdoc__sam0__tc__group.html#gga204bb4814c91e62e56d9297c05280aadac78b7c50f80b33d5ef15a63348279f17">TC_RELOAD_ACTION_RESYNC</a>  </td><td>Reload TC counter value on next GCLK cycle. Clear prescaler to zero.  </td></tr>
</table>
<p>The reload action to use will depend on the specific application being implemented. One example is when an external trigger for a reload occurs; if the TC uses the prescaler, the counter in the prescaler should not have a value between zero and the division factor. The TC counter and the counter in the prescaler should both start at zero. When the counter is set to re-trigger when it reaches the maximum value on the other hand, this is not the right option to use. In such a case it would be better if the prescaler is left unaltered when the re-trigger happens, letting the counter reset on the next GCLK cycle.</p>
<h3><a class="anchor" id="asfdoc_sam0_tc_module_overview_compare_match"></a>
Compare Match Operations</h3>
<p>In compare match operation, Compare/Capture registers are used in comparison with the counter value. When the timer's count value matches the value of a compare channel, a user defined action can be taken.</p>
<h4><a class="anchor" id="asfdoc_sam0_tc_module_overview_compare_match_timer"></a>
Basic Timer</h4>
<p>A Basic Timer is a simple application where compare match operations is used to determine when a specific period has elapsed. In Basic Timer operations, one or more values in the module's Compare/Capture registers are used to specify the time (as a number of prescaled GCLK cycles) when an action should be taken by the microcontroller. This can be an Interrupt Service Routine (ISR), event generator via the event system, or a software flag that is polled via the user application.</p>
<h4><a class="anchor" id="asfdoc_sam0_tc_module_overview_compare_match_wg"></a>
Waveform Generation</h4>
<p>Waveform generation enables the TC module to generate square waves, or if combined with an external passive low-pass filter; analog waveforms.</p>
<h4><a class="anchor" id="asfdoc_sam0_tc_module_overview_compare_match_wg_pwm"></a>
Waveform Generation - PWM</h4>
<p>Pulse width modulation is a form of waveform generation and a signalling technique that can be useful in many situations. When PWM mode is used, a digital pulse train with a configurable frequency and duty cycle can be generated by the TC module and output to a GPIO pin of the device.</p>
<p>Often PWM is used to communicate a control or information parameter to an external circuit or component. Differing impedances of the source generator and sink receiver circuits is less of an issue when using PWM compared to using an analog voltage value, as noise will not generally affect the signal's integrity to a meaningful extent.</p>
<p><a class="el" href="group__asfdoc__sam0__tc__group.html#asfdoc_sam0_tc_module_pwm_normal_diag">The figure below</a> illustrates operations and different states of the counter and its output when running the counter in PWM normal mode. As can be seen, the TOP value is unchanged and is set to MAX. The compare match value is changed at several points to illustrate the resulting waveform output changes. The PWM output is set to normal (i.e. non-inverted) output mode.</p>
<p><a class="anchor" id="asfdoc_sam0_tc_module_pwm_normal_diag"></a> </p>
<div class="image">
<img src="pwm_normal_ex.svg" alt="pwm_normal_ex.svg"/>
<div class="caption">
Example of PWM in Normal Mode, and Different Counter Operations</div></div>
<p> In <a class="el" href="group__asfdoc__sam0__tc__group.html#asfdoc_sam0_tc_module_pwm_match_diag">the figure below</a>, the counter is set to generate PWM in Match mode. The PWM output is inverted via the appropriate configuration option in the TC driver configuration structure. In this example, the counter value is changed once, but the compare match value is kept unchanged. As can be seen, it is possible to change the TOP value when running in PWM match mode.</p>
<p><a class="anchor" id="asfdoc_sam0_tc_module_pwm_match_diag"></a> </p>
<div class="image">
<img src="pwm_match_ex.svg" alt="pwm_match_ex.svg"/>
<div class="caption">
Example of PWM in Match Mode, and Different Counter Operations</div></div>
 <h4><a class="anchor" id="asfdoc_sam0_tc_module_overview_compare_match_wg_freq"></a>
Waveform Generation - Frequency</h4>
<p>Frequency Generation mode is in many ways identical to PWM generation. However, in Frequency Generation a toggle only occurs on the output when a match on a capture channels occurs. When the match is made, the timer value is reset, resulting in a variable frequency square wave with a fixed 50% duty cycle.</p>
<h4><a class="anchor" id="asfdoc_sam0_tc_module_overview_compare_match_capt"></a>
Capture Operations</h4>
<p>In capture operations, any event from the event system or a pin change can trigger a capture of the counter value. This captured counter value can be used as a timestamp for the event, or it can be used in frequency and pulse width capture.</p>
<h4><a class="anchor" id="asfdoc_sam0_tc_module_overview_compare_match_capt_event_capture"></a>
Capture Operations - Event</h4>
<p>Event capture is a simple use of the capture functionality, designed to create timestamps for specific events. When the TC module's input capture pin is externally toggled, the current timer count value is copied into a buffered register which can then be read out by the user application.</p>
<p>Note that when performing any capture operation, there is a risk that the counter reaches its top value (MAX) when counting up, or the bottom value (zero) when counting down, before the capture event occurs. This can distort the result, making event timestamps to appear shorter than reality; the user application should check for timer overflow when reading a capture result in order to detect this situation and perform an appropriate adjustment.</p>
<p>Before checking for a new capture, <a class="el" href="group__asfdoc__sam0__tc__group.html#gada6e9a6bd144c0c2e360d1fdef944cdd">TC_STATUS_COUNT_OVERFLOW</a> should be checked. The response to an overflow error is left to the user application, however it may be necessary to clear both the capture overflow flag and the capture flag upon each capture reading.</p>
<h4><a class="anchor" id="asfdoc_sam0_tc_module_overview_compare_match_capt_pwc"></a>
Capture Operations - Pulse Width</h4>
<p>Pulse Width Capture mode makes it possible to measure the pulse width and period of PWM signals. This mode uses two capture channels of the counter. This means that the counter module used for Pulse Width Capture can not be used for any other purpose. There are two modes for pulse width capture; Pulse Width Period (PWP) and Period Pulse Width (PPW). In PWP mode, capture channel 0 is used for storing the pulse width and capture channel 1 stores the observed period. While in PPW mode, the roles of the two capture channels is reversed.</p>
<p>As in the above example it is necessary to poll on interrupt flags to see if a new capture has happened and check that a capture overflow error has not occurred.</p>
<h3><a class="anchor" id="asfdoc_sam0_tc_module_overview_oneshot"></a>
One-shot Mode</h3>
<p>TC modules can be configured into a one-shot mode. When configured in this manner, starting the timer will cause it to count until the next overflow or underflow condition before automatically halting, waiting to be manually triggered by the user application software or an event signal from the event system.</p>
<h4><a class="anchor" id="asfdoc_sam0_tc_module_overview_inversion"></a>
Wave Generation Output Inversion</h4>
<p>The output of the wave generation can be inverted by hardware if desired, resulting in the logically inverted value being output to the configured device GPIO pin.</p>
<h2><a class="anchor" id="asfdoc_sam0_tc_special_considerations"></a>
Special Considerations</h2>
<p>The number of capture compare registers in each TC module is dependent on the specific SAM device being used, and in some cases the counter size.</p>
<p>The maximum amount of capture compare registers available in any SAM device is two when running in 32-bit mode and four in 8- and 16-bit modes.</p>
<h2><a class="anchor" id="asfdoc_sam0_tc_extra_info"></a>
Extra Information</h2>
<p>For extra information, see <a class="el" href="asfdoc_sam0_tc_extra.html">Extra Information for TC Driver</a>. This includes:</p>
<ul>
<li><a class="el" href="asfdoc_sam0_tc_extra.html#asfdoc_sam0_tc_extra_acronyms">Acronyms</a></li>
<li><a class="el" href="asfdoc_sam0_tc_extra.html#asfdoc_sam0_tc_extra_dependencies">Dependencies</a></li>
<li><a class="el" href="asfdoc_sam0_tc_extra.html#asfdoc_sam0_tc_extra_errata">Errata</a></li>
<li><a class="el" href="asfdoc_sam0_tc_extra.html#asfdoc_sam0_tc_extra_history">Module History</a></li>
</ul>
<h2><a class="anchor" id="asfdoc_sam0_tc_examples"></a>
Examples</h2>
<p>For a list of examples related to this driver, see <a class="el" href="asfdoc_sam0_tc_exqsg.html">Examples for TC Driver</a>.</p>
<h2><a class="anchor" id="asfdoc_sam0_tc_api_overview"></a>
API Overview</h2>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="gac837f9db5df1793578c195a979c6a9d3"></a><!-- doxytag: member="tc.h::NUMBER_OF_COMPARE_CAPTURE_CHANNELS" ref="gac837f9db5df1793578c195a979c6a9d3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__tc__group.html#gac837f9db5df1793578c195a979c6a9d3">NUMBER_OF_COMPARE_CAPTURE_CHANNELS</a>&#160;&#160;&#160;TC3_CC8_NUM</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Define port features set according to different device family </p>

</div>
</div>
<a class="anchor" id="ga94cdbe531468f0975311bc2ce36f5e1c"></a><!-- doxytag: member="tc.h::TC_INST_MAX_ID" ref="ga94cdbe531468f0975311bc2ce36f5e1c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__tc__group.html#ga94cdbe531468f0975311bc2ce36f5e1c">TC_INST_MAX_ID</a>&#160;&#160;&#160;7</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>TC Instance MAX ID Number. </p>

</div>
</div>
<a class="anchor" id="gac13395d51cc03b5c43eda7654649925f"></a><!-- doxytag: member="tc.h::TC_STATUS_CAPTURE_OVERFLOW" ref="gac13395d51cc03b5c43eda7654649925f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__tc__group.html#gac13395d51cc03b5c43eda7654649925f">TC_STATUS_CAPTURE_OVERFLOW</a>&#160;&#160;&#160;(1UL &lt;&lt; 3)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A new value was captured before the previous value was read, resulting in lost data. </p>

</div>
</div>
<a class="anchor" id="gae74e90dac05478452203a41a88853286"></a><!-- doxytag: member="tc.h::TC_STATUS_CHANNEL_0_MATCH" ref="gae74e90dac05478452203a41a88853286" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__tc__group.html#gae74e90dac05478452203a41a88853286">TC_STATUS_CHANNEL_0_MATCH</a>&#160;&#160;&#160;(1UL &lt;&lt; 0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Timer channel 0 has matched against its compare value, or has captured a new value. </p>

</div>
</div>
<a class="anchor" id="gaab140d8ac7858f45029fddf0fd3f4cf3"></a><!-- doxytag: member="tc.h::TC_STATUS_CHANNEL_1_MATCH" ref="gaab140d8ac7858f45029fddf0fd3f4cf3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__tc__group.html#gaab140d8ac7858f45029fddf0fd3f4cf3">TC_STATUS_CHANNEL_1_MATCH</a>&#160;&#160;&#160;(1UL &lt;&lt; 1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Timer channel 1 has matched against its compare value, or has captured a new value. </p>

</div>
</div>
<a class="anchor" id="gada6e9a6bd144c0c2e360d1fdef944cdd"></a><!-- doxytag: member="tc.h::TC_STATUS_COUNT_OVERFLOW" ref="gada6e9a6bd144c0c2e360d1fdef944cdd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__tc__group.html#gada6e9a6bd144c0c2e360d1fdef944cdd">TC_STATUS_COUNT_OVERFLOW</a>&#160;&#160;&#160;(1UL &lt;&lt; 4)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The timer count value has overflowed from its maximum value to its minimum when counting upward, or from its minimum value to its maximum when counting downward. </p>

</div>
</div>
<a class="anchor" id="ga73bfbe04c8834ec55242bcd0b678f94e"></a><!-- doxytag: member="tc.h::TC_STATUS_SYNC_READY" ref="ga73bfbe04c8834ec55242bcd0b678f94e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__tc__group.html#ga73bfbe04c8834ec55242bcd0b678f94e">TC_STATUS_SYNC_READY</a>&#160;&#160;&#160;(1UL &lt;&lt; 2)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Timer register synchronization has completed, and the synchronized count value may be read. </p>

</div>
</div>
<a class="anchor" id="ga3be501afca9dd97d2adb1959f30816a7"></a><!-- doxytag: member="tc.h::TC_WAVE_GENERATION_NORMAL_FREQ_MODE" ref="ga3be501afca9dd97d2adb1959f30816a7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__tc__group.html#ga3be501afca9dd97d2adb1959f30816a7">TC_WAVE_GENERATION_NORMAL_FREQ_MODE</a>&#160;&#160;&#160;TC_CTRLA_WAVEGEN_NFRQ</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>TC wave generation mode. </p>

</div>
</div>
<a class="anchor" id="ga50cb4d965dd6d607839abb71b3f034c0"></a><!-- doxytag: member="tc.h::TC_WAVEFORM_INVERT_CC0_MODE" ref="ga50cb4d965dd6d607839abb71b3f034c0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__tc__group.html#ga50cb4d965dd6d607839abb71b3f034c0">TC_WAVEFORM_INVERT_CC0_MODE</a>&#160;&#160;&#160;TC_CTRLC_INVEN(1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Waveform inversion mode. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga7d3fb5365e46bd4efae2885bd508067f"></a><!-- doxytag: member="tc.h::tc_callback" ref="ga7d3fb5365e46bd4efae2885bd508067f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tc__group.html#ga7d3fb5365e46bd4efae2885bd508067f">tc_callback</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enum for the possible callback types for the TC module. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga7d3fb5365e46bd4efae2885bd508067fade9a99ec0d7386cfff45671de03b8b6a"></a><!-- doxytag: member="TC_CALLBACK_OVERFLOW" ref="gga7d3fb5365e46bd4efae2885bd508067fade9a99ec0d7386cfff45671de03b8b6a" args="" -->TC_CALLBACK_OVERFLOW</em>&nbsp;</td><td>
<p>Callback for TC overflow. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga7d3fb5365e46bd4efae2885bd508067fab6fb975aff8c4ace0dbece4bf825332b"></a><!-- doxytag: member="TC_CALLBACK_ERROR" ref="gga7d3fb5365e46bd4efae2885bd508067fab6fb975aff8c4ace0dbece4bf825332b" args="" -->TC_CALLBACK_ERROR</em>&nbsp;</td><td>
<p>Callback for capture overflow error. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga7d3fb5365e46bd4efae2885bd508067fa03e7143b9984e00ad432db650abd69c6"></a><!-- doxytag: member="TC_CALLBACK_CC_CHANNEL0" ref="gga7d3fb5365e46bd4efae2885bd508067fa03e7143b9984e00ad432db650abd69c6" args="" -->TC_CALLBACK_CC_CHANNEL0</em>&nbsp;</td><td>
<p>Callback for capture compare channel 0. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga7d3fb5365e46bd4efae2885bd508067fae16450d1f8ef97cc1b129524b72efdf3"></a><!-- doxytag: member="TC_CALLBACK_CC_CHANNEL1" ref="gga7d3fb5365e46bd4efae2885bd508067fae16450d1f8ef97cc1b129524b72efdf3" args="" -->TC_CALLBACK_CC_CHANNEL1</em>&nbsp;</td><td>
<p>Callback for capture compare channel 1. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga7d3fb5365e46bd4efae2885bd508067faf76c479c366d3c15450245bb4ee9a856"></a><!-- doxytag: member="TC_CALLBACK_N" ref="gga7d3fb5365e46bd4efae2885bd508067faf76c479c366d3c15450245bb4ee9a856" args="" -->TC_CALLBACK_N</em>&nbsp;</td><td>
<p>Number of available callbacks. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga98aed17b995157e67b9322a45f0ed5f4"></a><!-- doxytag: member="tc.h::tc_clock_prescaler" ref="ga98aed17b995157e67b9322a45f0ed5f4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tc__group.html#ga98aed17b995157e67b9322a45f0ed5f4">tc_clock_prescaler</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TC clock prescaler values. </p>
<p>This enum is used to choose the clock prescaler configuration. The prescaler divides the clock frequency of the TC module to make the counter count slower. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga98aed17b995157e67b9322a45f0ed5f4abee76ee986e815120c67ff104dd77275"></a><!-- doxytag: member="TC_CLOCK_PRESCALER_DIV1" ref="gga98aed17b995157e67b9322a45f0ed5f4abee76ee986e815120c67ff104dd77275" args="" -->TC_CLOCK_PRESCALER_DIV1</em>&nbsp;</td><td>
<p>Divide clock by 1. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga98aed17b995157e67b9322a45f0ed5f4a6326eb4305153ea58ea18ee6a74bc8f0"></a><!-- doxytag: member="TC_CLOCK_PRESCALER_DIV2" ref="gga98aed17b995157e67b9322a45f0ed5f4a6326eb4305153ea58ea18ee6a74bc8f0" args="" -->TC_CLOCK_PRESCALER_DIV2</em>&nbsp;</td><td>
<p>Divide clock by 2. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga98aed17b995157e67b9322a45f0ed5f4a8c137a94b34809e544d50680c808da23"></a><!-- doxytag: member="TC_CLOCK_PRESCALER_DIV4" ref="gga98aed17b995157e67b9322a45f0ed5f4a8c137a94b34809e544d50680c808da23" args="" -->TC_CLOCK_PRESCALER_DIV4</em>&nbsp;</td><td>
<p>Divide clock by 4. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga98aed17b995157e67b9322a45f0ed5f4a3dbb4f263ba1e940954ffe8a667bf7d1"></a><!-- doxytag: member="TC_CLOCK_PRESCALER_DIV8" ref="gga98aed17b995157e67b9322a45f0ed5f4a3dbb4f263ba1e940954ffe8a667bf7d1" args="" -->TC_CLOCK_PRESCALER_DIV8</em>&nbsp;</td><td>
<p>Divide clock by 8. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga98aed17b995157e67b9322a45f0ed5f4aa0bec32bcf9a450d950f9ec9941a6c3a"></a><!-- doxytag: member="TC_CLOCK_PRESCALER_DIV16" ref="gga98aed17b995157e67b9322a45f0ed5f4aa0bec32bcf9a450d950f9ec9941a6c3a" args="" -->TC_CLOCK_PRESCALER_DIV16</em>&nbsp;</td><td>
<p>Divide clock by 16. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga98aed17b995157e67b9322a45f0ed5f4aea8fd1d9e795ec153e80cddc15ad501b"></a><!-- doxytag: member="TC_CLOCK_PRESCALER_DIV64" ref="gga98aed17b995157e67b9322a45f0ed5f4aea8fd1d9e795ec153e80cddc15ad501b" args="" -->TC_CLOCK_PRESCALER_DIV64</em>&nbsp;</td><td>
<p>Divide clock by 64. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga98aed17b995157e67b9322a45f0ed5f4a72552d0e6095d90da22981b7bd7a33ed"></a><!-- doxytag: member="TC_CLOCK_PRESCALER_DIV256" ref="gga98aed17b995157e67b9322a45f0ed5f4a72552d0e6095d90da22981b7bd7a33ed" args="" -->TC_CLOCK_PRESCALER_DIV256</em>&nbsp;</td><td>
<p>Divide clock by 256. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga98aed17b995157e67b9322a45f0ed5f4af1540c54586b7cd0c5e46c60162951ec"></a><!-- doxytag: member="TC_CLOCK_PRESCALER_DIV1024" ref="gga98aed17b995157e67b9322a45f0ed5f4af1540c54586b7cd0c5e46c60162951ec" args="" -->TC_CLOCK_PRESCALER_DIV1024</em>&nbsp;</td><td>
<p>Divide clock by 1024. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga01eca97dbfd588fd3ba0dcfd4792d857"></a><!-- doxytag: member="tc.h::tc_compare_capture_channel" ref="ga01eca97dbfd588fd3ba0dcfd4792d857" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tc__group.html#ga01eca97dbfd588fd3ba0dcfd4792d857">tc_compare_capture_channel</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Index of the compare capture channels. </p>
<p>This enum is used to specify which capture/compare channel to do operations on. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga01eca97dbfd588fd3ba0dcfd4792d857a5f6651d829a75778a759ce5a519b76a4"></a><!-- doxytag: member="TC_COMPARE_CAPTURE_CHANNEL_0" ref="gga01eca97dbfd588fd3ba0dcfd4792d857a5f6651d829a75778a759ce5a519b76a4" args="" -->TC_COMPARE_CAPTURE_CHANNEL_0</em>&nbsp;</td><td>
<p>Index of compare capture channel 0. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga01eca97dbfd588fd3ba0dcfd4792d857a8fcf38e3b831977347028475b5583141"></a><!-- doxytag: member="TC_COMPARE_CAPTURE_CHANNEL_1" ref="gga01eca97dbfd588fd3ba0dcfd4792d857a8fcf38e3b831977347028475b5583141" args="" -->TC_COMPARE_CAPTURE_CHANNEL_1</em>&nbsp;</td><td>
<p>Index of compare capture channel 1. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga28777c47943dfb2b5de0fd7ae14eac1f"></a><!-- doxytag: member="tc.h::tc_count_direction" ref="ga28777c47943dfb2b5de0fd7ae14eac1f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tc__group.html#ga28777c47943dfb2b5de0fd7ae14eac1f">tc_count_direction</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TC module count direction. </p>
<p>Timer/Counter count direction. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga28777c47943dfb2b5de0fd7ae14eac1faf247abdaef160b832fd09bc7597e8ca3"></a><!-- doxytag: member="TC_COUNT_DIRECTION_UP" ref="gga28777c47943dfb2b5de0fd7ae14eac1faf247abdaef160b832fd09bc7597e8ca3" args="" -->TC_COUNT_DIRECTION_UP</em>&nbsp;</td><td>
<p>Timer should count upward from zero to MAX. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga28777c47943dfb2b5de0fd7ae14eac1fade3defd512c1bff05ce6302c2d96b014"></a><!-- doxytag: member="TC_COUNT_DIRECTION_DOWN" ref="gga28777c47943dfb2b5de0fd7ae14eac1fade3defd512c1bff05ce6302c2d96b014" args="" -->TC_COUNT_DIRECTION_DOWN</em>&nbsp;</td><td>
<p>Timer should count downward to zero from MAX. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1b112627b81227c49c16b1a93e3321a0"></a><!-- doxytag: member="tc.h::tc_counter_size" ref="ga1b112627b81227c49c16b1a93e3321a0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tc__group.html#ga1b112627b81227c49c16b1a93e3321a0">tc_counter_size</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specifies if the counter is 8-, 16-, or 32-bit. </p>
<p>This enum specifies the maximum value it is possible to count to. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga1b112627b81227c49c16b1a93e3321a0abf2e8000eeeac2a4f259ba117d1ee934"></a><!-- doxytag: member="TC_COUNTER_SIZE_8BIT" ref="gga1b112627b81227c49c16b1a93e3321a0abf2e8000eeeac2a4f259ba117d1ee934" args="" -->TC_COUNTER_SIZE_8BIT</em>&nbsp;</td><td>
<p>The counter's maximum value is 0xFF, the period register is available to be used as top value. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga1b112627b81227c49c16b1a93e3321a0a07c9fe9d2a5e78a9c1be46ce540adad1"></a><!-- doxytag: member="TC_COUNTER_SIZE_16BIT" ref="gga1b112627b81227c49c16b1a93e3321a0a07c9fe9d2a5e78a9c1be46ce540adad1" args="" -->TC_COUNTER_SIZE_16BIT</em>&nbsp;</td><td>
<p>The counter's maximum value is 0xFFFF. There is no separate period register, to modify top one of the capture compare registers has to be used. This limits the amount of available channels. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga1b112627b81227c49c16b1a93e3321a0a7d28e63b11a550605d003c894fe134c5"></a><!-- doxytag: member="TC_COUNTER_SIZE_32BIT" ref="gga1b112627b81227c49c16b1a93e3321a0a7d28e63b11a550605d003c894fe134c5" args="" -->TC_COUNTER_SIZE_32BIT</em>&nbsp;</td><td>
<p>The counter's maximum value is 0xFFFFFFFF. There is no separate period register, to modify top one of the capture compare registers has to be used. This limits the amount of available channels. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4dcbf6cdb74bc3b7609ce8d16549462f"></a><!-- doxytag: member="tc.h::tc_event_action" ref="ga4dcbf6cdb74bc3b7609ce8d16549462f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tc__group.html#ga4dcbf6cdb74bc3b7609ce8d16549462f">tc_event_action</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Action to perform when the TC module is triggered by an event. </p>
<p>Event action to perform when the module is triggered by an event. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga4dcbf6cdb74bc3b7609ce8d16549462fa190e10df25f3f6a6c781cc751eb3489e"></a><!-- doxytag: member="TC_EVENT_ACTION_OFF" ref="gga4dcbf6cdb74bc3b7609ce8d16549462fa190e10df25f3f6a6c781cc751eb3489e" args="" -->TC_EVENT_ACTION_OFF</em>&nbsp;</td><td>
<p>No event action. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga4dcbf6cdb74bc3b7609ce8d16549462fa9696961ae81b1aba22582d8a35bdf14d"></a><!-- doxytag: member="TC_EVENT_ACTION_RETRIGGER" ref="gga4dcbf6cdb74bc3b7609ce8d16549462fa9696961ae81b1aba22582d8a35bdf14d" args="" -->TC_EVENT_ACTION_RETRIGGER</em>&nbsp;</td><td>
<p>Re-trigger on event. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga4dcbf6cdb74bc3b7609ce8d16549462fa07b969496782cb311ddb13cfafb36aff"></a><!-- doxytag: member="TC_EVENT_ACTION_INCREMENT_COUNTER" ref="gga4dcbf6cdb74bc3b7609ce8d16549462fa07b969496782cb311ddb13cfafb36aff" args="" -->TC_EVENT_ACTION_INCREMENT_COUNTER</em>&nbsp;</td><td>
<p>Increment counter on event. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga4dcbf6cdb74bc3b7609ce8d16549462fac06c64382b572d0464138ae51b7876df"></a><!-- doxytag: member="TC_EVENT_ACTION_START" ref="gga4dcbf6cdb74bc3b7609ce8d16549462fac06c64382b572d0464138ae51b7876df" args="" -->TC_EVENT_ACTION_START</em>&nbsp;</td><td>
<p>Start counter on event. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga4dcbf6cdb74bc3b7609ce8d16549462fa4957024d607401030b128f9b775edb7d"></a><!-- doxytag: member="TC_EVENT_ACTION_PPW" ref="gga4dcbf6cdb74bc3b7609ce8d16549462fa4957024d607401030b128f9b775edb7d" args="" -->TC_EVENT_ACTION_PPW</em>&nbsp;</td><td>
<p>Store period in capture register 0, pulse width in capture register 1. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga4dcbf6cdb74bc3b7609ce8d16549462face22a0756d93b16a9b70511fe226a893"></a><!-- doxytag: member="TC_EVENT_ACTION_PWP" ref="gga4dcbf6cdb74bc3b7609ce8d16549462face22a0756d93b16a9b70511fe226a893" args="" -->TC_EVENT_ACTION_PWP</em>&nbsp;</td><td>
<p>Store pulse width in capture register 0, period in capture register 1. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga204bb4814c91e62e56d9297c05280aad"></a><!-- doxytag: member="tc.h::tc_reload_action" ref="ga204bb4814c91e62e56d9297c05280aad" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tc__group.html#ga204bb4814c91e62e56d9297c05280aad">tc_reload_action</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TC Counter reload action enum. </p>
<p>This enum specify how the counter and prescaler should reload. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga204bb4814c91e62e56d9297c05280aadaea50b7d7b79cfbd72298720e0f6d51ed"></a><!-- doxytag: member="TC_RELOAD_ACTION_GCLK" ref="gga204bb4814c91e62e56d9297c05280aadaea50b7d7b79cfbd72298720e0f6d51ed" args="" -->TC_RELOAD_ACTION_GCLK</em>&nbsp;</td><td>
<p>The counter is reloaded/reset on the next GCLK and starts counting on the prescaler clock. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga204bb4814c91e62e56d9297c05280aada97857fba0947beb9110ab79d2990e559"></a><!-- doxytag: member="TC_RELOAD_ACTION_PRESC" ref="gga204bb4814c91e62e56d9297c05280aada97857fba0947beb9110ab79d2990e559" args="" -->TC_RELOAD_ACTION_PRESC</em>&nbsp;</td><td>
<p>The counter is reloaded/reset on the next prescaler clock. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga204bb4814c91e62e56d9297c05280aadac78b7c50f80b33d5ef15a63348279f17"></a><!-- doxytag: member="TC_RELOAD_ACTION_RESYNC" ref="gga204bb4814c91e62e56d9297c05280aadac78b7c50f80b33d5ef15a63348279f17" args="" -->TC_RELOAD_ACTION_RESYNC</em>&nbsp;</td><td>
<p>The counter is reloaded/reset on the next GCLK, and the prescaler is restarted as well. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gae7f1302b7e3d675e471a554668b49d64"></a><!-- doxytag: member="tc.h::tc_wave_generation" ref="gae7f1302b7e3d675e471a554668b49d64" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tc__group.html#gae7f1302b7e3d675e471a554668b49d64">tc_wave_generation</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TC wave generation mode enum. </p>
<p>This enum is used to select which mode to run the wave generation in. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggae7f1302b7e3d675e471a554668b49d64a544e51b015f20263a9499ce28a0596e7"></a><!-- doxytag: member="TC_WAVE_GENERATION_NORMAL_FREQ" ref="ggae7f1302b7e3d675e471a554668b49d64a544e51b015f20263a9499ce28a0596e7" args="" -->TC_WAVE_GENERATION_NORMAL_FREQ</em>&nbsp;</td><td>
<p>Top is maximum, except in 8-bit counter size where it is the PER register. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae7f1302b7e3d675e471a554668b49d64a4c9b3fe1ad9a1d2c0f5d8544c0923b9f"></a><!-- doxytag: member="TC_WAVE_GENERATION_MATCH_FREQ" ref="ggae7f1302b7e3d675e471a554668b49d64a4c9b3fe1ad9a1d2c0f5d8544c0923b9f" args="" -->TC_WAVE_GENERATION_MATCH_FREQ</em>&nbsp;</td><td>
<p>Top is CC0, except in 8-bit counter size where it is the PER register. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae7f1302b7e3d675e471a554668b49d64aad9dc196250ce8ca5a98c7e49cf0c1a9"></a><!-- doxytag: member="TC_WAVE_GENERATION_NORMAL_PWM" ref="ggae7f1302b7e3d675e471a554668b49d64aad9dc196250ce8ca5a98c7e49cf0c1a9" args="" -->TC_WAVE_GENERATION_NORMAL_PWM</em>&nbsp;</td><td>
<p>Top is maximum, except in 8-bit counter size where it is the PER register. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae7f1302b7e3d675e471a554668b49d64a973273609713f828ce491f56fbf035d2"></a><!-- doxytag: member="TC_WAVE_GENERATION_MATCH_PWM" ref="ggae7f1302b7e3d675e471a554668b49d64a973273609713f828ce491f56fbf035d2" args="" -->TC_WAVE_GENERATION_MATCH_PWM</em>&nbsp;</td><td>
<p>Top is CC0, except in 8-bit counter size where it is the PER register. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf681729d6b5f963705871f7d80754166"></a><!-- doxytag: member="tc.h::tc_waveform_invert_output" ref="gaf681729d6b5f963705871f7d80754166" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tc__group.html#gaf681729d6b5f963705871f7d80754166">tc_waveform_invert_output</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Waveform inversion mode. </p>
<p>Output waveform inversion mode. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggaf681729d6b5f963705871f7d80754166a292cfce35b768eecd69f2a4320aaa96b"></a><!-- doxytag: member="TC_WAVEFORM_INVERT_OUTPUT_NONE" ref="ggaf681729d6b5f963705871f7d80754166a292cfce35b768eecd69f2a4320aaa96b" args="" -->TC_WAVEFORM_INVERT_OUTPUT_NONE</em>&nbsp;</td><td>
<p>No inversion of the waveform output. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaf681729d6b5f963705871f7d80754166af3ebe1706d0f442c6388619bc3d9fa58"></a><!-- doxytag: member="TC_WAVEFORM_INVERT_OUTPUT_CHANNEL_0" ref="ggaf681729d6b5f963705871f7d80754166af3ebe1706d0f442c6388619bc3d9fa58" args="" -->TC_WAVEFORM_INVERT_OUTPUT_CHANNEL_0</em>&nbsp;</td><td>
<p>Invert output from compare channel 0. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaf681729d6b5f963705871f7d80754166a97327e36339fbad207e7150d6ba7b283"></a><!-- doxytag: member="TC_WAVEFORM_INVERT_OUTPUT_CHANNEL_1" ref="ggaf681729d6b5f963705871f7d80754166a97327e36339fbad207e7150d6ba7b283" args="" -->TC_WAVEFORM_INVERT_OUTPUT_CHANNEL_1</em>&nbsp;</td><td>
<p>Invert output from compare channel 1. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu Jun 23 2016 20:43:14 for Atmel Radio by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Atmel Radio: SAM RTC Count Driver (RTC COUNT)</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Atmel Radio
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">SAM RTC Count Driver (RTC COUNT)</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrtc__count__events.html">rtc_count_events</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">RTC Count event enable/disable structure.  <a href="structrtc__count__events.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrtc__module.html">rtc_module</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Device structure.  <a href="structrtc__module.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrtc__count__config.html">rtc_count_config</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">RTC Count configuration structure.  <a href="structrtc__count__config.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa206a97ea7ed2613fe15b5dff9895af4"></a><!-- doxytag: member="asfdoc_sam0_rtc_count_group::rtc_count_callback_t" ref="gaa206a97ea7ed2613fe15b5dff9895af4" args=")(void)" -->
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>rtc_count_callback_t</b> )(void)</td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ga1c6c05a342b2711713cfac6fb3d6256c">rtc_count_mode</a> { <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#gga1c6c05a342b2711713cfac6fb3d6256cac1469285bb822ce84f262cd4117e8edc">RTC_COUNT_MODE_16BIT</a> =  0, 
<a class="el" href="group__asfdoc__sam0__rtc__count__group.html#gga1c6c05a342b2711713cfac6fb3d6256cad94f227d25afd2fa3c26ef9a5a33e4d8">RTC_COUNT_MODE_32BIT</a> =  1
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Available operation modes for the RTC.  <a href="group__asfdoc__sam0__rtc__count__group.html#ga1c6c05a342b2711713cfac6fb3d6256c">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#gadfcb8b12ca245948cbedc1ad81c3e589">rtc_count_compare</a> { <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ggadfcb8b12ca245948cbedc1ad81c3e589ac7340ee61643d3bdb0a7b4264335f080">RTC_COUNT_COMPARE_0</a> =  0
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Available compare channels.  <a href="group__asfdoc__sam0__rtc__count__group.html#gadfcb8b12ca245948cbedc1ad81c3e589">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ga8bb78ce49e1064cd0877fad28ce2056e">rtc_count_callback</a> { <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#gga8bb78ce49e1064cd0877fad28ce2056ea641386c6cebf26ec75e8ff459649b1c2">RTC_COUNT_CALLBACK_COMPARE_0</a> =  0, 
<a class="el" href="group__asfdoc__sam0__rtc__count__group.html#gga8bb78ce49e1064cd0877fad28ce2056ea4b9dc9f91c490289fd69c8b7a4fdb607">RTC_COUNT_CALLBACK_OVERFLOW</a>, 
<a class="el" href="group__asfdoc__sam0__rtc__count__group.html#gga8bb78ce49e1064cd0877fad28ce2056eab754fc34d7a072f5411dba039caaa8a2">_RTC_COUNT_CALLBACK_N</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback types.  <a href="group__asfdoc__sam0__rtc__count__group.html#ga8bb78ce49e1064cd0877fad28ce2056e">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#gacce60ab36a74de9a173788f4aa896d15">rtc_count_prescaler</a> { <br/>
&#160;&#160;<a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ggacce60ab36a74de9a173788f4aa896d15aa5a98b865348eb598140b2a4247916e9">RTC_COUNT_PRESCALER_DIV_1</a> =  RTC_MODE0_CTRL_PRESCALER_DIV1, 
<a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ggacce60ab36a74de9a173788f4aa896d15a312d3c72451ac000e95d335183ad7ec3">RTC_COUNT_PRESCALER_DIV_2</a> =  RTC_MODE0_CTRL_PRESCALER_DIV2, 
<a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ggacce60ab36a74de9a173788f4aa896d15ac82d71266c2f83c3d51b51fedd1ae920">RTC_COUNT_PRESCALER_DIV_4</a> =  RTC_MODE0_CTRL_PRESCALER_DIV4, 
<a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ggacce60ab36a74de9a173788f4aa896d15ac0061a5a79673614095663596f9e79f4">RTC_COUNT_PRESCALER_DIV_8</a> =  RTC_MODE0_CTRL_PRESCALER_DIV8, 
<br/>
&#160;&#160;<a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ggacce60ab36a74de9a173788f4aa896d15a4e17e7e9d43d022235a7550dccffcddd">RTC_COUNT_PRESCALER_DIV_16</a> =  RTC_MODE0_CTRL_PRESCALER_DIV16, 
<a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ggacce60ab36a74de9a173788f4aa896d15a3b83f1963700137784f61cd05ef49b7e">RTC_COUNT_PRESCALER_DIV_32</a> =  RTC_MODE0_CTRL_PRESCALER_DIV32, 
<a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ggacce60ab36a74de9a173788f4aa896d15a8b59673e870fd1205aa08b667fcc58b6">RTC_COUNT_PRESCALER_DIV_64</a> =  RTC_MODE0_CTRL_PRESCALER_DIV64, 
<a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ggacce60ab36a74de9a173788f4aa896d15a2d736f3fdd6be715588ee09d7a8d1deb">RTC_COUNT_PRESCALER_DIV_128</a> =  RTC_MODE0_CTRL_PRESCALER_DIV128, 
<br/>
&#160;&#160;<a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ggacce60ab36a74de9a173788f4aa896d15a4d6f94d95f1e40f463a83148a57edcfa">RTC_COUNT_PRESCALER_DIV_256</a> =  RTC_MODE0_CTRL_PRESCALER_DIV256, 
<a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ggacce60ab36a74de9a173788f4aa896d15ab58a33623afbb13b74dcbd7e50e7760b">RTC_COUNT_PRESCALER_DIV_512</a> =  RTC_MODE0_CTRL_PRESCALER_DIV512, 
<a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ggacce60ab36a74de9a173788f4aa896d15a9766bc273a9d05a8345615c5707eb4a7">RTC_COUNT_PRESCALER_DIV_1024</a> =  RTC_MODE0_CTRL_PRESCALER_DIV1024
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">RTC input clock prescaler settings.  <a href="group__asfdoc__sam0__rtc__count__group.html#gacce60ab36a74de9a173788f4aa896d15">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ga728e9addb0162893a3a2c9100ebd7920">FEATURE_RTC_CONTINUOUSLY_UPDATED</a></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Configuration and Initialization</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga161d6cf1f6f717e8c6c650dc587cdf7a"></a><!-- doxytag: member="asfdoc_sam0_rtc_count_group::rtc_count_reset" ref="ga161d6cf1f6f717e8c6c650dc587cdf7a" args="(struct rtc_module *const module)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>rtc_count_reset</b> (struct <a class="el" href="structrtc__module.html">rtc_module</a> *const module)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad49e022ac982b14f592b4741fe076add"></a><!-- doxytag: member="asfdoc_sam0_rtc_count_group::rtc_count_enable" ref="gad49e022ac982b14f592b4741fe076add" args="(struct rtc_module *const module)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>rtc_count_enable</b> (struct <a class="el" href="structrtc__module.html">rtc_module</a> *const module)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga40f97a58f45fe3fdeec606c155d4d8f3"></a><!-- doxytag: member="asfdoc_sam0_rtc_count_group::rtc_count_disable" ref="ga40f97a58f45fe3fdeec606c155d4d8f3" args="(struct rtc_module *const module)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>rtc_count_disable</b> (struct <a class="el" href="structrtc__module.html">rtc_module</a> *const module)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaff43df79be7aeea0d559eafbe5fdbdc3"></a><!-- doxytag: member="asfdoc_sam0_rtc_count_group::rtc_count_init" ref="gaff43df79be7aeea0d559eafbe5fdbdc3" args="(struct rtc_module *const module, Rtc *const hw, const struct rtc_count_config *const config)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rtc_count_init</b> (struct <a class="el" href="structrtc__module.html">rtc_module</a> *const module, <a class="el" href="union_rtc.html">Rtc</a> *const hw, const struct <a class="el" href="structrtc__count__config.html">rtc_count_config</a> *const config)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadccb737db7dd01d7190a7f9e18b23a1b"></a><!-- doxytag: member="asfdoc_sam0_rtc_count_group::rtc_count_frequency_correction" ref="gadccb737db7dd01d7190a7f9e18b23a1b" args="(struct rtc_module *const module, const int8_t value)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rtc_count_frequency_correction</b> (struct <a class="el" href="structrtc__module.html">rtc_module</a> *const module, const int8_t value)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Count and Compare Value Management</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3770c2c6f82daca6ca28670cd87be46f"></a><!-- doxytag: member="asfdoc_sam0_rtc_count_group::rtc_count_set_count" ref="ga3770c2c6f82daca6ca28670cd87be46f" args="(struct rtc_module *const module, const uint32_t count_value)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rtc_count_set_count</b> (struct <a class="el" href="structrtc__module.html">rtc_module</a> *const module, const uint32_t count_value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3ad10283f223feb3c958ccabe9d0662a"></a><!-- doxytag: member="asfdoc_sam0_rtc_count_group::rtc_count_get_count" ref="ga3ad10283f223feb3c958ccabe9d0662a" args="(struct rtc_module *const module)" -->
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>rtc_count_get_count</b> (struct <a class="el" href="structrtc__module.html">rtc_module</a> *const module)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga56c76be0e0fdfb5b1f9a883f396756f4"></a><!-- doxytag: member="asfdoc_sam0_rtc_count_group::rtc_count_set_compare" ref="ga56c76be0e0fdfb5b1f9a883f396756f4" args="(struct rtc_module *const module, const uint32_t comp_value, const enum rtc_count_compare comp_index)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rtc_count_set_compare</b> (struct <a class="el" href="structrtc__module.html">rtc_module</a> *const module, const uint32_t comp_value, const enum <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#gadfcb8b12ca245948cbedc1ad81c3e589">rtc_count_compare</a> comp_index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga40e535c1375a99492e114722af93b675"></a><!-- doxytag: member="asfdoc_sam0_rtc_count_group::rtc_count_get_compare" ref="ga40e535c1375a99492e114722af93b675" args="(struct rtc_module *const module, uint32_t *const comp_value, const enum rtc_count_compare comp_index)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rtc_count_get_compare</b> (struct <a class="el" href="structrtc__module.html">rtc_module</a> *const module, uint32_t *const comp_value, const enum <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#gadfcb8b12ca245948cbedc1ad81c3e589">rtc_count_compare</a> comp_index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac0b0d3a10ee5368b5484f99e6b6fecb8"></a><!-- doxytag: member="asfdoc_sam0_rtc_count_group::rtc_count_set_period" ref="gac0b0d3a10ee5368b5484f99e6b6fecb8" args="(struct rtc_module *const module, uint16_t period_value)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rtc_count_set_period</b> (struct <a class="el" href="structrtc__module.html">rtc_module</a> *const module, uint16_t period_value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga747385c5686f746a64f118705c22c894"></a><!-- doxytag: member="asfdoc_sam0_rtc_count_group::rtc_count_get_period" ref="ga747385c5686f746a64f118705c22c894" args="(struct rtc_module *const module, uint16_t *const period_value)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rtc_count_get_period</b> (struct <a class="el" href="structrtc__module.html">rtc_module</a> *const module, uint16_t *const period_value)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Status Management</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga354d81abc8c33bc39a238418611b3239"></a><!-- doxytag: member="asfdoc_sam0_rtc_count_group::rtc_count_is_compare_match" ref="ga354d81abc8c33bc39a238418611b3239" args="(struct rtc_module *const module, const enum rtc_count_compare comp_index)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>rtc_count_is_compare_match</b> (struct <a class="el" href="structrtc__module.html">rtc_module</a> *const module, const enum <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#gadfcb8b12ca245948cbedc1ad81c3e589">rtc_count_compare</a> comp_index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga51cd67b23c2a4716d09b08bf2422a222"></a><!-- doxytag: member="asfdoc_sam0_rtc_count_group::rtc_count_clear_compare_match" ref="ga51cd67b23c2a4716d09b08bf2422a222" args="(struct rtc_module *const module, const enum rtc_count_compare comp_index)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rtc_count_clear_compare_match</b> (struct <a class="el" href="structrtc__module.html">rtc_module</a> *const module, const enum <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#gadfcb8b12ca245948cbedc1ad81c3e589">rtc_count_compare</a> comp_index)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>This driver for Atmel&reg; | SMART SAM devices provides an interface for the configuration and management of the device's Real Time Clock functionality in Count operating mode, for the configuration and retrieval of the current RTC counter value. The following driver API modes are covered by this manual:</p>
<ul>
<li>Polled APIs</li>
</ul>
<p>The following peripherals are used by this module:</p>
<ul>
<li>RTC (Real Time Clock)</li>
</ul>
<p>The following devices can use this module:</p>
<ul>
<li>Atmel | SMART SAM D20/D21</li>
<li>Atmel | SMART SAM R21</li>
<li>Atmel | SMART SAM D10/D11</li>
<li>Atmel | SMART SAM L21</li>
<li>Atmel | SMART SAM DAx</li>
<li>Atmel | SMART SAM C20/C21</li>
</ul>
<p>The outline of this documentation is as follows:</p>
<ul>
<li><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#asfdoc_sam0_rtc_count_prerequisites">Prerequisites</a></li>
<li><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#asfdoc_sam0_rtc_count_module_overview">Module Overview</a></li>
<li><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#asfdoc_sam0_rtc_count_special_considerations">Special Considerations</a></li>
<li><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#asfdoc_sam0_rtc_count_extra_info">Extra Information</a></li>
<li><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#asfdoc_sam0_rtc_count_examples">Examples</a></li>
<li><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#asfdoc_sam0_rtc_count_api_overview">API Overview</a></li>
</ul>
<h2><a class="anchor" id="asfdoc_sam0_rtc_count_prerequisites"></a>
Prerequisites</h2>
<p>There are no prerequisites for this module.</p>
<h2><a class="anchor" id="asfdoc_sam0_rtc_count_module_overview"></a>
Module Overview</h2>
<p>The RTC module in the SAM devices is a 32-bit counter, with a 10-bit programmable prescaler. Typically, the RTC clock is run continuously, including in the device's low-power sleep modes, to track the current time and date information. The RTC can be used as a source to wake up the system at a scheduled time or periodically using the alarm functions.</p>
<p>In this driver, the RTC is operated in Count mode. This allows for an easy integration of an asynchronous counter into a user application, which is capable of operating while the device is in sleep mode.</p>
<p>Whilst operating in Count mode, the RTC features:</p>
<ul>
<li>16-bit counter mode<ul>
<li>Selectable counter period</li>
<li>Up to six configurable compare values</li>
</ul>
</li>
<li>32-bit counter mode<ul>
<li>Clear counter value on match</li>
<li>Up to four configurable compare values</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="asfdoc_sam0_rtc_count_features"></a>
Driver Feature Macro Definition</h3>
<table class="doxtable">
<tr>
<th>Driver Feature Macro </th><th>Supported devices  </th></tr>
<tr>
<td>FEATURE_RTC_PERIODIC_INT </td><td>SAML21/C20/C21  </td></tr>
<tr>
<td>FEATURE_RTC_PRESCALER_OFF </td><td>SAML21/C20/C21  </td></tr>
<tr>
<td>FEATURE_RTC_CLOCK_SELECTION </td><td>SAML21/C20/C21  </td></tr>
<tr>
<td>FEATURE_RTC_GENERAL_PURPOSE_REG </td><td>SAML21  </td></tr>
<tr>
<td>FEATURE_RTC_CONTINUOUSLY_UPDATED </td><td>SAMD20, SAMD21, SAMR21, SAMD10, SAMD11, SAMDAx  </td></tr>
</table>
<dl class="note"><dt><b>Note:</b></dt><dd>The specific features are only available in the driver when the selected device supports those features.</dd></dl>
<h2><a class="anchor" id="asfdoc_sam0_rtc_count_module_overview_compares"></a>
Compare and Overflow</h2>
<p>The RTC can be used with up to 4/6 compare values (depending on selected operation mode). These compare values will trigger on match with the current RTC counter value, and can be set up to trigger an interrupt, event, or both. The RTC can also be configured to clear the counter value on compare match in 32-bit mode, resetting the count value back to zero.</p>
<p>If the RTC is operated without the Clear on Match option enabled, or in 16-bit mode, the RTC counter value will instead be cleared on overflow once the maximum count value has been reached:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ COUNT_{MAX} = 2^{32}-1 \]" src="form_3.png"/>
</p>
<p> for 32-bit counter mode, and </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ COUNT_{MAX} = 2^{16}-1 \]" src="form_4.png"/>
</p>
<p> for 16-bit counter mode.</p>
<p>When running in 16-bit mode, the overflow value is selectable with a period value. The counter overflow will then occur when the counter value reaches the specified period value.</p>
<h3><a class="anchor" id="asfdoc_sam0_rtc_count_module_overview_periodic"></a>
Periodic Events</h3>
<p>The RTC can generate events at periodic intervals, allowing for direct peripheral actions without CPU intervention. The periodic events can be generated on the upper eight bits of the RTC prescaler, and will be generated on the rising edge transition of the specified bit. The resulting periodic frequency can be calculated by the following formula:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ f_{PERIODIC}=\frac{f_{ASY}}{2^{n+3}} \]" src="form_5.png"/>
</p>
<p>Where <img class="formulaInl" alt="$f_{ASY}$" src="form_6.png"/> refers to the <em>asynchronous</em> clock set up in the RTC module configuration. The <b>n</b> parameter is the event source generator index of the RTC module. If the asynchronous clock is operated at the recommended frequency of 1KHz, the formula results in the values shown in <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#asfdoc_sam0_rtc_count_module_rtc_hz">the table below</a>.</p>
<p><a class="anchor" id="asfdoc_sam0_rtc_count_module_rtc_hz"></a> </p>
<table class="doxtable">
<caption align="bottom">RTC Event Frequencies for Each Prescaler Bit Using a 1KHz Clock</caption>
<tr>
<th>n </th><th>Periodic event  </th></tr>
<tr>
<td>7 </td><td>1Hz  </td></tr>
<tr>
<td>6 </td><td>2Hz  </td></tr>
<tr>
<td>5 </td><td>4Hz  </td></tr>
<tr>
<td>4 </td><td>8Hz  </td></tr>
<tr>
<td>3 </td><td>16Hz  </td></tr>
<tr>
<td>2 </td><td>32Hz  </td></tr>
<tr>
<td>1 </td><td>64Hz  </td></tr>
<tr>
<td>0 </td><td>128Hz  </td></tr>
</table>
<dl class="note"><dt><b>Note:</b></dt><dd>The connection of events between modules requires the use of the SAM Event System Driver (EVENTS) to route output event of one module to the the input event of another. For more information on event routing, refer to the event driver documentation.</dd></dl>
<h3><a class="anchor" id="asfdoc_sam0_rtc_count_module_overview_correction"></a>
Digital Frequency Correction</h3>
<p>The RTC module contains Digital Frequency Correction logic to compensate for inaccurate source clock frequencies which would otherwise result in skewed time measurements. The correction scheme requires that at least two bits in the RTC module prescaler are reserved by the correction logic. As a result of this implementation, frequency correction is only available when the RTC is running from a 1Hz reference clock.</p>
<p>The correction procedure is implemented by subtracting or adding a single cycle from the RTC prescaler every 1024 RTC GCLK cycles. The adjustment is applied the specified number of time (maximum 127) over 976 of these periods. The corresponding correction in PPM will be given by:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ Correction(PPM) = \frac{VALUE}{999424}10^6 \]" src="form_7.png"/>
</p>
<p>The RTC clock will tick faster if provided with a positive correction value, and slower when given a negative correction value.</p>
<h2><a class="anchor" id="asfdoc_sam0_rtc_count_special_considerations"></a>
Special Considerations</h2>
<h3><a class="anchor" id="asfdoc_sam0_rtc_count_special_considerations_clock"></a>
Clock Setup</h3>
<h4><a class="anchor" id="asfdoc_sam0_rtc_count_clock_samd_r"></a>
SAM D20/D21/R21/D10/D11/DA0/DA1 Clock Setup</h4>
<p>The RTC is typically clocked by a specialized GCLK generator that has a smaller prescaler than the others. By default the RTC clock is on, selected to use the internal 32KHz RC-oscillator with a prescaler of 32, giving a resulting clock frequency of 1KHz to the RTC. When the internal RTC prescaler is set to 1024, this yields an end-frequency of 1Hz.</p>
<p>The implementer also has the option to set other end-frequencies. <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#asfdoc_sam0_rtc_count_rtc_out_freq">The table below</a> lists the available RTC frequencies for each possible GCLK and RTC input prescaler options.</p>
<p><a class="anchor" id="asfdoc_sam0_rtc_count_rtc_out_freq"></a> </p>
<table class="doxtable">
<caption align="bottom">RTC Output Frequencies from Allowable Input Clocks</caption>
<tr>
<th>End-frequency </th><th>GCLK prescaler </th><th>RTC prescaler  </th></tr>
<tr>
<td>32KHz </td><td>1 </td><td>1  </td></tr>
<tr>
<td>1KHz </td><td>32 </td><td>1  </td></tr>
<tr>
<td>1Hz </td><td>32 </td><td>1024  </td></tr>
</table>
<p>The overall RTC module clocking scheme is shown in <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#asfdoc_sam0_rtc_count_rtc_clock_fig">the figure below</a>.</p>
<p><a class="anchor" id="asfdoc_sam0_rtc_count_rtc_clock_fig"></a> </p>
<div align="center">
</div>
<h4><a class="anchor" id="asfdoc_sam0_rtc_count_clock_saml"></a>
SAM L21/C20/C21 Clock Setup</h4>
<p>The RTC clock can be selected from OSC32K,XOSC32K or OSCULP32K , and a 32KHz or 1KHz oscillator clock frequency is required. This clock must be configured and enabled in the 32KHz oscillator controller before using the RTC.</p>
<p>The table below lists the available RTC clock <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#asfdoc_sam0_rtc_count_rtc_clk">asfdoc_sam0_rtc_count_rtc_clk</a></p>
<p><a class="anchor" id="asfdoc_sam0_rtc_count_rtc_clk"></a> </p>
<table class="doxtable">
<caption align="bottom">RTC clocks source</caption>
<tr>
<th>RTC clock frequency </th><th>Clock source </th><th>Description  </th></tr>
<tr>
<td>1.024KHz </td><td>ULP1K </td><td>1.024KHz from 32KHz internal ULP oscillator  </td></tr>
<tr>
<td>32.768KHz </td><td>ULP32K </td><td>32.768KHz from 32KHz internal ULP oscillator  </td></tr>
<tr>
<td>1.024KHz </td><td>OSC1K </td><td>1.024KHz from 32KHz internal oscillator  </td></tr>
<tr>
<td>32.768KHz </td><td>OSC32K </td><td>32.768KHz from 32KHz internal oscillator  </td></tr>
<tr>
<td>1.024KHz </td><td>XOSC1K </td><td>1.024KHz from 32KHz internal oscillator  </td></tr>
<tr>
<td>32.768KHz </td><td>XOSC32K </td><td>32.768KHz from 32KHz external crystal oscillator  </td></tr>
</table>
<h2><a class="anchor" id="asfdoc_sam0_rtc_count_extra_info"></a>
Extra Information</h2>
<p>For extra information, see <a class="el" href="asfdoc_sam0_rtc_count_extra.html">Extra Information for RTC COUNT Driver</a>. This includes:</p>
<ul>
<li><a class="el" href="asfdoc_sam0_rtc_count_extra.html#asfdoc_sam0_rtc_count_extra_acronyms">Acronyms</a></li>
<li><a class="el" href="asfdoc_sam0_rtc_count_extra.html#asfdoc_sam0_rtc_count_extra_dependencies">Dependencies</a></li>
<li><a class="el" href="asfdoc_sam0_rtc_count_extra.html#asfdoc_sam0_rtc_count_extra_errata">Errata</a></li>
<li><a class="el" href="asfdoc_sam0_rtc_count_extra.html#asfdoc_sam0_rtc_count_extra_history">Module History</a></li>
</ul>
<h2><a class="anchor" id="asfdoc_sam0_rtc_count_examples"></a>
Examples</h2>
<p>For a list of examples related to this driver, see <a class="el" href="asfdoc_sam0_rtc_count_exqsg.html">Examples for RTC (COUNT) Driver</a>.</p>
<h2><a class="anchor" id="asfdoc_sam0_rtc_count_api_overview"></a>
API Overview</h2>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga728e9addb0162893a3a2c9100ebd7920"></a><!-- doxytag: member="rtc_count.h::FEATURE_RTC_CONTINUOUSLY_UPDATED" ref="ga728e9addb0162893a3a2c9100ebd7920" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ga728e9addb0162893a3a2c9100ebd7920">FEATURE_RTC_CONTINUOUSLY_UPDATED</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Define port features set according to different device family RTC continuously updated. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga8bb78ce49e1064cd0877fad28ce2056e"></a><!-- doxytag: member="rtc_count.h::rtc_count_callback" ref="ga8bb78ce49e1064cd0877fad28ce2056e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ga8bb78ce49e1064cd0877fad28ce2056e">rtc_count_callback</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback types. </p>
<p>The available callback types for the RTC count module. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga8bb78ce49e1064cd0877fad28ce2056ea641386c6cebf26ec75e8ff459649b1c2"></a><!-- doxytag: member="RTC_COUNT_CALLBACK_COMPARE_0" ref="gga8bb78ce49e1064cd0877fad28ce2056ea641386c6cebf26ec75e8ff459649b1c2" args="" -->RTC_COUNT_CALLBACK_COMPARE_0</em>&nbsp;</td><td>
<p>Callback for compare channel 0. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga8bb78ce49e1064cd0877fad28ce2056ea4b9dc9f91c490289fd69c8b7a4fdb607"></a><!-- doxytag: member="RTC_COUNT_CALLBACK_OVERFLOW" ref="gga8bb78ce49e1064cd0877fad28ce2056ea4b9dc9f91c490289fd69c8b7a4fdb607" args="" -->RTC_COUNT_CALLBACK_OVERFLOW</em>&nbsp;</td><td>
<p>Callback for overflow. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga8bb78ce49e1064cd0877fad28ce2056eab754fc34d7a072f5411dba039caaa8a2"></a><!-- doxytag: member="_RTC_COUNT_CALLBACK_N" ref="gga8bb78ce49e1064cd0877fad28ce2056eab754fc34d7a072f5411dba039caaa8a2" args="" -->_RTC_COUNT_CALLBACK_N</em>&nbsp;</td><td>
<p>Total number of callbacks. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gadfcb8b12ca245948cbedc1ad81c3e589"></a><!-- doxytag: member="rtc_count.h::rtc_count_compare" ref="gadfcb8b12ca245948cbedc1ad81c3e589" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#gadfcb8b12ca245948cbedc1ad81c3e589">rtc_count_compare</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Available compare channels. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Not all compare channels are available in all devices and modes. </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggadfcb8b12ca245948cbedc1ad81c3e589ac7340ee61643d3bdb0a7b4264335f080"></a><!-- doxytag: member="RTC_COUNT_COMPARE_0" ref="ggadfcb8b12ca245948cbedc1ad81c3e589ac7340ee61643d3bdb0a7b4264335f080" args="" -->RTC_COUNT_COMPARE_0</em>&nbsp;</td><td>
<p>Compare channel 0. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1c6c05a342b2711713cfac6fb3d6256c"></a><!-- doxytag: member="rtc_count.h::rtc_count_mode" ref="ga1c6c05a342b2711713cfac6fb3d6256c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ga1c6c05a342b2711713cfac6fb3d6256c">rtc_count_mode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Available operation modes for the RTC. </p>
<p>RTC Count operating modes, to select the counting width and associated module operation. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga1c6c05a342b2711713cfac6fb3d6256cac1469285bb822ce84f262cd4117e8edc"></a><!-- doxytag: member="RTC_COUNT_MODE_16BIT" ref="gga1c6c05a342b2711713cfac6fb3d6256cac1469285bb822ce84f262cd4117e8edc" args="" -->RTC_COUNT_MODE_16BIT</em>&nbsp;</td><td>
<p>RTC Count module operates in 16-bit mode. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga1c6c05a342b2711713cfac6fb3d6256cad94f227d25afd2fa3c26ef9a5a33e4d8"></a><!-- doxytag: member="RTC_COUNT_MODE_32BIT" ref="gga1c6c05a342b2711713cfac6fb3d6256cad94f227d25afd2fa3c26ef9a5a33e4d8" args="" -->RTC_COUNT_MODE_32BIT</em>&nbsp;</td><td>
<p>RTC Count module operates in 32-bit mode. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gacce60ab36a74de9a173788f4aa896d15"></a><!-- doxytag: member="rtc_count.h::rtc_count_prescaler" ref="gacce60ab36a74de9a173788f4aa896d15" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#gacce60ab36a74de9a173788f4aa896d15">rtc_count_prescaler</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>RTC input clock prescaler settings. </p>
<p>The available input clock prescaler values for the RTC count module. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggacce60ab36a74de9a173788f4aa896d15aa5a98b865348eb598140b2a4247916e9"></a><!-- doxytag: member="RTC_COUNT_PRESCALER_DIV_1" ref="ggacce60ab36a74de9a173788f4aa896d15aa5a98b865348eb598140b2a4247916e9" args="" -->RTC_COUNT_PRESCALER_DIV_1</em>&nbsp;</td><td>
<p>RTC input clock frequency is prescaled by a factor of 1. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggacce60ab36a74de9a173788f4aa896d15a312d3c72451ac000e95d335183ad7ec3"></a><!-- doxytag: member="RTC_COUNT_PRESCALER_DIV_2" ref="ggacce60ab36a74de9a173788f4aa896d15a312d3c72451ac000e95d335183ad7ec3" args="" -->RTC_COUNT_PRESCALER_DIV_2</em>&nbsp;</td><td>
<p>RTC input clock frequency is prescaled by a factor of 2. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggacce60ab36a74de9a173788f4aa896d15ac82d71266c2f83c3d51b51fedd1ae920"></a><!-- doxytag: member="RTC_COUNT_PRESCALER_DIV_4" ref="ggacce60ab36a74de9a173788f4aa896d15ac82d71266c2f83c3d51b51fedd1ae920" args="" -->RTC_COUNT_PRESCALER_DIV_4</em>&nbsp;</td><td>
<p>RTC input clock frequency is prescaled by a factor of 4. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggacce60ab36a74de9a173788f4aa896d15ac0061a5a79673614095663596f9e79f4"></a><!-- doxytag: member="RTC_COUNT_PRESCALER_DIV_8" ref="ggacce60ab36a74de9a173788f4aa896d15ac0061a5a79673614095663596f9e79f4" args="" -->RTC_COUNT_PRESCALER_DIV_8</em>&nbsp;</td><td>
<p>RTC input clock frequency is prescaled by a factor of 8. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggacce60ab36a74de9a173788f4aa896d15a4e17e7e9d43d022235a7550dccffcddd"></a><!-- doxytag: member="RTC_COUNT_PRESCALER_DIV_16" ref="ggacce60ab36a74de9a173788f4aa896d15a4e17e7e9d43d022235a7550dccffcddd" args="" -->RTC_COUNT_PRESCALER_DIV_16</em>&nbsp;</td><td>
<p>RTC input clock frequency is prescaled by a factor of 16. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggacce60ab36a74de9a173788f4aa896d15a3b83f1963700137784f61cd05ef49b7e"></a><!-- doxytag: member="RTC_COUNT_PRESCALER_DIV_32" ref="ggacce60ab36a74de9a173788f4aa896d15a3b83f1963700137784f61cd05ef49b7e" args="" -->RTC_COUNT_PRESCALER_DIV_32</em>&nbsp;</td><td>
<p>RTC input clock frequency is prescaled by a factor of 32. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggacce60ab36a74de9a173788f4aa896d15a8b59673e870fd1205aa08b667fcc58b6"></a><!-- doxytag: member="RTC_COUNT_PRESCALER_DIV_64" ref="ggacce60ab36a74de9a173788f4aa896d15a8b59673e870fd1205aa08b667fcc58b6" args="" -->RTC_COUNT_PRESCALER_DIV_64</em>&nbsp;</td><td>
<p>RTC input clock frequency is prescaled by a factor of 64. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggacce60ab36a74de9a173788f4aa896d15a2d736f3fdd6be715588ee09d7a8d1deb"></a><!-- doxytag: member="RTC_COUNT_PRESCALER_DIV_128" ref="ggacce60ab36a74de9a173788f4aa896d15a2d736f3fdd6be715588ee09d7a8d1deb" args="" -->RTC_COUNT_PRESCALER_DIV_128</em>&nbsp;</td><td>
<p>RTC input clock frequency is prescaled by a factor of 128. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggacce60ab36a74de9a173788f4aa896d15a4d6f94d95f1e40f463a83148a57edcfa"></a><!-- doxytag: member="RTC_COUNT_PRESCALER_DIV_256" ref="ggacce60ab36a74de9a173788f4aa896d15a4d6f94d95f1e40f463a83148a57edcfa" args="" -->RTC_COUNT_PRESCALER_DIV_256</em>&nbsp;</td><td>
<p>RTC input clock frequency is prescaled by a factor of 256. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggacce60ab36a74de9a173788f4aa896d15ab58a33623afbb13b74dcbd7e50e7760b"></a><!-- doxytag: member="RTC_COUNT_PRESCALER_DIV_512" ref="ggacce60ab36a74de9a173788f4aa896d15ab58a33623afbb13b74dcbd7e50e7760b" args="" -->RTC_COUNT_PRESCALER_DIV_512</em>&nbsp;</td><td>
<p>RTC input clock frequency is prescaled by a factor of 512. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggacce60ab36a74de9a173788f4aa896d15a9766bc273a9d05a8345615c5707eb4a7"></a><!-- doxytag: member="RTC_COUNT_PRESCALER_DIV_1024" ref="ggacce60ab36a74de9a173788f4aa896d15a9766bc273a9d05a8345615c5707eb4a7" args="" -->RTC_COUNT_PRESCALER_DIV_1024</em>&nbsp;</td><td>
<p>RTC input clock frequency is prescaled by a factor of 1024. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu Jun 23 2016 20:43:13 for Atmel Radio by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>

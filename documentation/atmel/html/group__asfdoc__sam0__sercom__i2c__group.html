<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Atmel Radio: Asfdoc_sam0_sercom_i2c_group</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Atmel Radio
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">Asfdoc_sam0_sercom_i2c_group</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structi2c__master__packet.html">i2c_master_packet</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">I<sup>2</sup>C master packet for read/write.  <a href="structi2c__master__packet.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structi2c__master__module.html">i2c_master_module</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">SERCOM I<sup>2</sup>C Master driver software device instance structure.  <a href="structi2c__master__module.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structi2c__master__config.html">i2c_master_config</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration structure for the I<sup>2</sup>C Master device.  <a href="structi2c__master__config.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structi2c__slave__packet.html">i2c_slave_packet</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">I<sup>2</sup>C slave packet for read/write.  <a href="structi2c__slave__packet.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structi2c__slave__module.html">i2c_slave_module</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">SERCOM I<sup>2</sup>C Slave driver software device instance structure.  <a href="structi2c__slave__module.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structi2c__slave__config.html">i2c_slave_config</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration structure for the I<sup>2</sup>C Slave device.  <a href="structi2c__slave__config.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa42d31a3a422d51828ea8ab6e1ab57f2"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::i2c_master_callback_t" ref="gaa42d31a3a422d51828ea8ab6e1ab57f2" args=")(struct i2c_master_module *const module)" -->
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_master_callback_t</b> )(struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gad1bf386f7d839c87db6421113488c1b2">i2c_slave_callback_t</a> )(struct <a class="el" href="structi2c__slave__module.html">i2c_slave_module</a> *const module)</td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga9f73c4fbd225704c2e0da23319c25555">i2c_master_interrupt_flag</a> { <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gga9f73c4fbd225704c2e0da23319c25555a39c138d5f063f3d43b4e974870364d2e">I2C_MASTER_INTERRUPT_WRITE</a> =  0, 
<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gga9f73c4fbd225704c2e0da23319c25555a3087032aa3a5218a0cdc54179d9e1d09">I2C_MASTER_INTERRUPT_READ</a> =  1
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt flags.  <a href="group__asfdoc__sam0__sercom__i2c__group.html#ga9f73c4fbd225704c2e0da23319c25555">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gadd8aa7cabbddc1cd2c1a8753c9b99d20">i2c_master_start_hold_time</a> { <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ggadd8aa7cabbddc1cd2c1a8753c9b99d20a85f0b592eef5f8b5ecae9f2cca2d4cd1">I2C_MASTER_START_HOLD_TIME_DISABLED</a> =  SERCOM_I2CM_CTRLA_SDAHOLD(0), 
<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ggadd8aa7cabbddc1cd2c1a8753c9b99d20a41403c4a18a1220f031c99e52f384e39">I2C_MASTER_START_HOLD_TIME_50NS_100NS</a> =  SERCOM_I2CM_CTRLA_SDAHOLD(1), 
<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ggadd8aa7cabbddc1cd2c1a8753c9b99d20acc3f7849862510590acc2e3bebc29d0c">I2C_MASTER_START_HOLD_TIME_300NS_600NS</a> =  SERCOM_I2CM_CTRLA_SDAHOLD(2), 
<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ggadd8aa7cabbddc1cd2c1a8753c9b99d20a38cf380ace8d180528eb34bc38b7da9e">I2C_MASTER_START_HOLD_TIME_400NS_800NS</a> =  SERCOM_I2CM_CTRLA_SDAHOLD(3)
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Values for hold time after start bit.  <a href="group__asfdoc__sam0__sercom__i2c__group.html#gadd8aa7cabbddc1cd2c1a8753c9b99d20">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga4640bee224bf835f4c38d7702be0742c">i2c_master_inactive_timeout</a> { <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gga4640bee224bf835f4c38d7702be0742ca52414c5127a26a6811f30324102cc3b1">I2C_MASTER_INACTIVE_TIMEOUT_DISABLED</a> =  SERCOM_I2CM_CTRLA_INACTOUT(0), 
<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gga4640bee224bf835f4c38d7702be0742ca9e204c432b52e77b4d34a5b64d4432e9">I2C_MASTER_INACTIVE_TIMEOUT_55US</a> =  SERCOM_I2CM_CTRLA_INACTOUT(1), 
<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gga4640bee224bf835f4c38d7702be0742ca9f37beb962cccc4538b0c226c921c553">I2C_MASTER_INACTIVE_TIMEOUT_105US</a> =  SERCOM_I2CM_CTRLA_INACTOUT(2), 
<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gga4640bee224bf835f4c38d7702be0742ca7412f98fd47572a75dc17727fdf735d0">I2C_MASTER_INACTIVE_TIMEOUT_205US</a> =  SERCOM_I2CM_CTRLA_INACTOUT(3)
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Values for inactive bus time-out.  <a href="group__asfdoc__sam0__sercom__i2c__group.html#ga4640bee224bf835f4c38d7702be0742c">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gace1e0023f2eee92565496a2e30006548">i2c_master_baud_rate</a> { <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ggace1e0023f2eee92565496a2e30006548a24ddfbe034a690d3a553a17508cbd625">I2C_MASTER_BAUD_RATE_100KHZ</a> =  100, 
<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ggace1e0023f2eee92565496a2e30006548a970dccbbc3dd1d01c1070db6d9aa24cb">I2C_MASTER_BAUD_RATE_400KHZ</a> =  400
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">I<sup>2</sup>C frequencies.  <a href="group__asfdoc__sam0__sercom__i2c__group.html#gace1e0023f2eee92565496a2e30006548">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga844ac2694772642cfee08a29c50bf054">i2c_master_callback</a> { <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gga844ac2694772642cfee08a29c50bf054a37c3aab3ceb2bddf4b42672386fd64f2">I2C_MASTER_CALLBACK_WRITE_COMPLETE</a> =  0, 
<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gga844ac2694772642cfee08a29c50bf054a64edbb1496288626e11b020a887ffcf8">I2C_MASTER_CALLBACK_READ_COMPLETE</a> =  1, 
<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gga844ac2694772642cfee08a29c50bf054a97597905a886849275665273da79442f">I2C_MASTER_CALLBACK_ERROR</a> =  2, 
<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gga844ac2694772642cfee08a29c50bf054a3563390afb1b1b26a6252e0b5981ed06">_I2C_MASTER_CALLBACK_N</a> =  3
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback types.  <a href="group__asfdoc__sam0__sercom__i2c__group.html#ga844ac2694772642cfee08a29c50bf054">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga90235bfca166d527fba19fe230475a14">i2c_slave_callback</a> { <br/>
&#160;&#160;<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gga90235bfca166d527fba19fe230475a14aa9c97e1fc8a197338d5b4cd4998c5b94">I2C_SLAVE_CALLBACK_WRITE_COMPLETE</a>, 
<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gga90235bfca166d527fba19fe230475a14ad4ea2cf32f73781d19a113e8ede05523">I2C_SLAVE_CALLBACK_READ_COMPLETE</a>, 
<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gga90235bfca166d527fba19fe230475a14a284f6a1b843168f5ec6fe9a2ae1f7a92">I2C_SLAVE_CALLBACK_READ_REQUEST</a>, 
<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gga90235bfca166d527fba19fe230475a14a0c29d5624ede1c4f3d7a1ba08350a4bc">I2C_SLAVE_CALLBACK_WRITE_REQUEST</a>, 
<br/>
&#160;&#160;<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gga90235bfca166d527fba19fe230475a14aebef553e929b1169ba9d1278e190279c">I2C_SLAVE_CALLBACK_ERROR</a>, 
<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gga90235bfca166d527fba19fe230475a14affe940500251691e9cd032c050bcd5bc">I2C_SLAVE_CALLBACK_ERROR_LAST_TRANSFER</a>, 
<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gga90235bfca166d527fba19fe230475a14afbf34deacc91b2dbe2108c4fc51ad975">_I2C_SLAVE_CALLBACK_N</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback types.  <a href="group__asfdoc__sam0__sercom__i2c__group.html#ga90235bfca166d527fba19fe230475a14">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga81c9919ecf8f0eab59841a6168969d7c">i2c_slave_sda_hold_time</a> { <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gga81c9919ecf8f0eab59841a6168969d7ca490e60c6bb9abe06173e7edfcb512809">I2C_SLAVE_SDA_HOLD_TIME_DISABLED</a>, 
<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gga81c9919ecf8f0eab59841a6168969d7cab7eb05387febe74423129d3a4b6ac411">I2C_SLAVE_SDA_HOLD_TIME_50NS_100NS</a>, 
<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gga81c9919ecf8f0eab59841a6168969d7ca7a5d0d4bd995f0118aec5b8bb095eb96">I2C_SLAVE_SDA_HOLD_TIME_300NS_600NS</a>, 
<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gga81c9919ecf8f0eab59841a6168969d7cab2adc4496b7f8bcd36520953fd7d1de3">I2C_SLAVE_SDA_HOLD_TIME_400NS_800NS</a>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gadbcbd4ca061dd80196ce37aeed5eec87">i2c_slave_address_mode</a> { <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ggadbcbd4ca061dd80196ce37aeed5eec87a4f9748991dfdca99901a21920f41c2d5">I2C_SLAVE_ADDRESS_MODE_MASK</a> =  SERCOM_I2CS_CTRLB_AMODE(0), 
<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ggadbcbd4ca061dd80196ce37aeed5eec87abd5fecb8a7003ce607199143aab45eff">I2C_SLAVE_ADDRESS_MODE_TWO_ADDRESSES</a> =  SERCOM_I2CS_CTRLB_AMODE(1), 
<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ggadbcbd4ca061dd80196ce37aeed5eec87aba4ec9aa23be4e24902b642738d53247">I2C_SLAVE_ADDRESS_MODE_RANGE</a> =  SERCOM_I2CS_CTRLB_AMODE(2)
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gac9afde0120288a8a42cb3b1dc6594cc6">i2c_slave_direction</a> { <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ggac9afde0120288a8a42cb3b1dc6594cc6aee5e40bb4e1283ac7bb3f7ab926f1006">I2C_SLAVE_DIRECTION_READ</a>, 
<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ggac9afde0120288a8a42cb3b1dc6594cc6a7ad9455bf2e71899dbd12ea1c2893708">I2C_SLAVE_DIRECTION_WRITE</a>, 
<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ggac9afde0120288a8a42cb3b1dc6594cc6a8eeec94989a66ecb30219353ef1b3456">I2C_SLAVE_DIRECTION_NONE</a>
 }</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Configuration and Initialization</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1c174d923b525f6d60402f66bc9c3451"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::i2c_master_init" ref="ga1c174d923b525f6d60402f66bc9c3451" args="(struct i2c_master_module *const module, Sercom *const hw, const struct i2c_master_config *const config)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_master_init</b> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module, <a class="el" href="union_sercom.html">Sercom</a> *const hw, const struct <a class="el" href="structi2c__master__config.html">i2c_master_config</a> *const config)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6dc5e9982ce4d7c6acc68cb69c57883d"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::i2c_master_reset" ref="ga6dc5e9982ce4d7c6acc68cb69c57883d" args="(struct i2c_master_module *const module)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_master_reset</b> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Read and Write</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga238a755f972b9c3287131cda5fc25725"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::i2c_master_read_packet_wait" ref="ga238a755f972b9c3287131cda5fc25725" args="(struct i2c_master_module *const module, struct i2c_master_packet *const packet)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_master_read_packet_wait</b> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module, struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const packet)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa8b27eb9e3a8ae0f907bf7078d4001f0"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::i2c_master_read_packet_wait_no_stop" ref="gaa8b27eb9e3a8ae0f907bf7078d4001f0" args="(struct i2c_master_module *const module, struct i2c_master_packet *const packet)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_master_read_packet_wait_no_stop</b> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module, struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const packet)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6c07057fe2534e8b4a3ce2cfe2dafc1b"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::i2c_master_write_packet_wait" ref="ga6c07057fe2534e8b4a3ce2cfe2dafc1b" args="(struct i2c_master_module *const module, struct i2c_master_packet *const packet)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_master_write_packet_wait</b> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module, struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const packet)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4d874599c2bff10cd08f5474041c66bb"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::i2c_master_write_packet_wait_no_stop" ref="ga4d874599c2bff10cd08f5474041c66bb" args="(struct i2c_master_module *const module, struct i2c_master_packet *const packet)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_master_write_packet_wait_no_stop</b> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module, struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const packet)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6bddf9e717847b5fa8462596e7e1489c"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::i2c_master_send_stop" ref="ga6bddf9e717847b5fa8462596e7e1489c" args="(struct i2c_master_module *const module)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_master_send_stop</b> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf9bb3b3174c1fc602c3097bc40eadcef"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::i2c_master_send_nack" ref="gaf9bb3b3174c1fc602c3097bc40eadcef" args="(struct i2c_master_module *const module)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_master_send_nack</b> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga54cf79ca8aa80e2163881ca4164e35f7"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::i2c_master_read_byte" ref="ga54cf79ca8aa80e2163881ca4164e35f7" args="(struct i2c_master_module *const module, uint8_t *byte)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_master_read_byte</b> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module, uint8_t *byte)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaee2de09ec9474331f354eec703b80b6e"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::i2c_master_write_byte" ref="gaee2de09ec9474331f354eec703b80b6e" args="(struct i2c_master_module *const module, uint8_t byte)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_master_write_byte</b> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module, uint8_t byte)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae39b9f208966b0857f0bb61dc4dffd83"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::i2c_master_read_packet_wait_no_nack" ref="gae39b9f208966b0857f0bb61dc4dffd83" args="(struct i2c_master_module *const module, struct i2c_master_packet *const packet)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_master_read_packet_wait_no_nack</b> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module, struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const packet)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Callbacks</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5ba2356881237729e03a8c4637b96306"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::_i2c_master_interrupt_handler" ref="ga5ba2356881237729e03a8c4637b96306" args="(uint8_t instance)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>_i2c_master_interrupt_handler</b> (uint8_t instance)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf3216a045490437ec87ba14ffeee5e7b"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::i2c_master_register_callback" ref="gaf3216a045490437ec87ba14ffeee5e7b" args="(struct i2c_master_module *const module, i2c_master_callback_t callback, enum i2c_master_callback callback_type)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_master_register_callback</b> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module, i2c_master_callback_t callback, enum <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga844ac2694772642cfee08a29c50bf054">i2c_master_callback</a> callback_type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7432de8165fe68a4fdb1919a33b58250"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::i2c_master_unregister_callback" ref="ga7432de8165fe68a4fdb1919a33b58250" args="(struct i2c_master_module *const module, enum i2c_master_callback callback_type)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_master_unregister_callback</b> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module, enum <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga844ac2694772642cfee08a29c50bf054">i2c_master_callback</a> callback_type)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Read and Write, Interrupt-Driven</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga15590b71928847daf2826c9cc0482717"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::i2c_master_read_bytes" ref="ga15590b71928847daf2826c9cc0482717" args="(struct i2c_master_module *const module, struct i2c_master_packet *const packet)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_master_read_bytes</b> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module, struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const packet)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga909337c580a4cd52dd209baaf2d399af"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::i2c_master_read_packet_job" ref="ga909337c580a4cd52dd209baaf2d399af" args="(struct i2c_master_module *const module, struct i2c_master_packet *const packet)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_master_read_packet_job</b> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module, struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const packet)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa56093f3196b0f0ff368fa2ee21827f9"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::i2c_master_read_packet_job_no_stop" ref="gaa56093f3196b0f0ff368fa2ee21827f9" args="(struct i2c_master_module *const module, struct i2c_master_packet *const packet)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_master_read_packet_job_no_stop</b> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module, struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const packet)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaff359c3a99851202a0190014d823c29"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::i2c_master_read_packet_job_no_nack" ref="gaaff359c3a99851202a0190014d823c29" args="(struct i2c_master_module *const module, struct i2c_master_packet *const packet)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_master_read_packet_job_no_nack</b> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module, struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const packet)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6f4d4f641c2bb1a905ad95a41ed3f741"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::i2c_master_write_bytes" ref="ga6f4d4f641c2bb1a905ad95a41ed3f741" args="(struct i2c_master_module *const module, struct i2c_master_packet *const packet)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_master_write_bytes</b> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module, struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const packet)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5527434ebf5f0442a9f9ed9146005cba"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::i2c_master_write_packet_job" ref="ga5527434ebf5f0442a9f9ed9146005cba" args="(struct i2c_master_module *const module, struct i2c_master_packet *const packet)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_master_write_packet_job</b> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module, struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const packet)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf1ee33c8f9b65ede18200b33500dae7d"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::i2c_master_write_packet_job_no_stop" ref="gaf1ee33c8f9b65ede18200b33500dae7d" args="(struct i2c_master_module *const module, struct i2c_master_packet *const packet)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_master_write_packet_job_no_stop</b> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module, struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const packet)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
I2C Slave Status Flags</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpcda5bac779b387622ee4cdf0fde53009"></a> I<sup>2</sup>C slave status flags, returned by i2c_slave_get_status() and cleared by i2c_slave_clear_status(). </p>
</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga24c5dc6079d8cec3d35ac3315f88958a">I2C_SLAVE_STATUS_ADDRESS_MATCH</a>&#160;&#160;&#160;(1UL &lt;&lt; 0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gad51487f143d69d120529c2dc390704f8">I2C_SLAVE_STATUS_DATA_READY</a>&#160;&#160;&#160;(1UL &lt;&lt; 1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga801b54f4d3848901da67186733534b5a">I2C_SLAVE_STATUS_STOP_RECEIVED</a>&#160;&#160;&#160;(1UL &lt;&lt; 2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gad35c4a3d06b7dee73006f8fcc2583fc9">I2C_SLAVE_STATUS_CLOCK_HOLD</a>&#160;&#160;&#160;(1UL &lt;&lt; 3)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga40dee3f12952a54efe2fba5c2231dee6">I2C_SLAVE_STATUS_SCL_LOW_TIMEOUT</a>&#160;&#160;&#160;(1UL &lt;&lt; 4)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga76abc9f40af15bfa050207bbf678f0dc">I2C_SLAVE_STATUS_REPEATED_START</a>&#160;&#160;&#160;(1UL &lt;&lt; 5)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga914b5b47cfc5d49ee7aba3703a2c8e7a">I2C_SLAVE_STATUS_RECEIVED_NACK</a>&#160;&#160;&#160;(1UL &lt;&lt; 6)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gab6303af78b1582ab1e20e9a9151acdd6">I2C_SLAVE_STATUS_COLLISION</a>&#160;&#160;&#160;(1UL &lt;&lt; 7)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gab08dbf9b4f59eccae146764173c14659">I2C_SLAVE_STATUS_BUS_ERROR</a>&#160;&#160;&#160;(1UL &lt;&lt; 8)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Configuration and Initialization</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7f904434c4f7ef8ba569a7e77b5c6ba9"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::i2c_slave_init" ref="ga7f904434c4f7ef8ba569a7e77b5c6ba9" args="(struct i2c_slave_module *const module, Sercom *const hw, const struct i2c_slave_config *const config)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_slave_init</b> (struct <a class="el" href="structi2c__slave__module.html">i2c_slave_module</a> *const module, <a class="el" href="union_sercom.html">Sercom</a> *const hw, const struct <a class="el" href="structi2c__slave__config.html">i2c_slave_config</a> *const config)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga02d7752b843f88c1e39eb9ea40f763dd"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::i2c_slave_reset" ref="ga02d7752b843f88c1e39eb9ea40f763dd" args="(struct i2c_slave_module *const module)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_slave_reset</b> (struct <a class="el" href="structi2c__slave__module.html">i2c_slave_module</a> *const module)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Read and Write</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1624ab45b506b497eb5452477fecd2a5"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::i2c_slave_write_packet_wait" ref="ga1624ab45b506b497eb5452477fecd2a5" args="(struct i2c_slave_module *const module, struct i2c_slave_packet *const packet)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_slave_write_packet_wait</b> (struct <a class="el" href="structi2c__slave__module.html">i2c_slave_module</a> *const module, struct <a class="el" href="structi2c__slave__packet.html">i2c_slave_packet</a> *const packet)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga73ffedce40a4bdf73ac8c9335ca41187"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::i2c_slave_read_packet_wait" ref="ga73ffedce40a4bdf73ac8c9335ca41187" args="(struct i2c_slave_module *const module, struct i2c_slave_packet *const packet)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_slave_read_packet_wait</b> (struct <a class="el" href="structi2c__slave__module.html">i2c_slave_module</a> *const module, struct <a class="el" href="structi2c__slave__packet.html">i2c_slave_packet</a> *const packet)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaabfb1738fbc9fa9ec10537c96402e4a2"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::i2c_slave_get_direction_wait" ref="gaabfb1738fbc9fa9ec10537c96402e4a2" args="(struct i2c_slave_module *const module)" -->
enum <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gac9afde0120288a8a42cb3b1dc6594cc6">i2c_slave_direction</a>&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_slave_get_direction_wait</b> (struct <a class="el" href="structi2c__slave__module.html">i2c_slave_module</a> *const module)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Status Management</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3b0837da909aaa222f1e566e55af7322"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::i2c_slave_get_status" ref="ga3b0837da909aaa222f1e566e55af7322" args="(struct i2c_slave_module *const module)" -->
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_slave_get_status</b> (struct <a class="el" href="structi2c__slave__module.html">i2c_slave_module</a> *const module)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga827aa5286941d811505b49ea86aca83b"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::i2c_slave_clear_status" ref="ga827aa5286941d811505b49ea86aca83b" args="(struct i2c_slave_module *const module, uint32_t status_flags)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_slave_clear_status</b> (struct <a class="el" href="structi2c__slave__module.html">i2c_slave_module</a> *const module, uint32_t status_flags)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Address Match Functionality</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad5b29f9124fcd5c0696f1a07a4b7719a"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::i2c_slave_enable_nack_on_address" ref="gad5b29f9124fcd5c0696f1a07a4b7719a" args="(struct i2c_slave_module *const module)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_slave_enable_nack_on_address</b> (struct <a class="el" href="structi2c__slave__module.html">i2c_slave_module</a> *const module)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaea7a2bb090e95770a5b311c91cb30126"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::i2c_slave_disable_nack_on_address" ref="gaea7a2bb090e95770a5b311c91cb30126" args="(struct i2c_slave_module *const module)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_slave_disable_nack_on_address</b> (struct <a class="el" href="structi2c__slave__module.html">i2c_slave_module</a> *const module)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Callbacks</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8bceeeb398c0674287184ca7d2fb3b52"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::_i2c_slave_interrupt_handler" ref="ga8bceeeb398c0674287184ca7d2fb3b52" args="(uint8_t instance)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>_i2c_slave_interrupt_handler</b> (uint8_t instance)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0031f29f821c3139939dec9cee0a0362"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::i2c_slave_register_callback" ref="ga0031f29f821c3139939dec9cee0a0362" args="(struct i2c_slave_module *const module, i2c_slave_callback_t callback, enum i2c_slave_callback callback_type)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_slave_register_callback</b> (struct <a class="el" href="structi2c__slave__module.html">i2c_slave_module</a> *const module, <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gad1bf386f7d839c87db6421113488c1b2">i2c_slave_callback_t</a> callback, enum <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga90235bfca166d527fba19fe230475a14">i2c_slave_callback</a> callback_type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2d3e5ec2fbc0c1bace602489603d138c"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::i2c_slave_unregister_callback" ref="ga2d3e5ec2fbc0c1bace602489603d138c" args="(struct i2c_slave_module *const module, enum i2c_slave_callback callback_type)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_slave_unregister_callback</b> (struct <a class="el" href="structi2c__slave__module.html">i2c_slave_module</a> *const module, enum <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga90235bfca166d527fba19fe230475a14">i2c_slave_callback</a> callback_type)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Read and Write, Interrupt-Driven</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga958cc5609a2bc6b6c367a91a4b109a79"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::i2c_slave_read_packet_job" ref="ga958cc5609a2bc6b6c367a91a4b109a79" args="(struct i2c_slave_module *const module, struct i2c_slave_packet *const packet)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_slave_read_packet_job</b> (struct <a class="el" href="structi2c__slave__module.html">i2c_slave_module</a> *const module, struct <a class="el" href="structi2c__slave__packet.html">i2c_slave_packet</a> *const packet)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafee45ced1df737475041dc58ae2a4e59"></a><!-- doxytag: member="asfdoc_sam0_sercom_i2c_group::i2c_slave_write_packet_job" ref="gafee45ced1df737475041dc58ae2a4e59" args="(struct i2c_slave_module *const module, struct i2c_slave_packet *const packet)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_slave_write_packet_job</b> (struct <a class="el" href="structi2c__slave__module.html">i2c_slave_module</a> *const module, struct <a class="el" href="structi2c__slave__packet.html">i2c_slave_packet</a> *const packet)</td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga24c5dc6079d8cec3d35ac3315f88958a"></a><!-- doxytag: member="i2c_slave.h::I2C_SLAVE_STATUS_ADDRESS_MATCH" ref="ga24c5dc6079d8cec3d35ac3315f88958a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga24c5dc6079d8cec3d35ac3315f88958a">I2C_SLAVE_STATUS_ADDRESS_MATCH</a>&#160;&#160;&#160;(1UL &lt;&lt; 0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Address Match. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Should only be cleared internally by driver. </dd></dl>

</div>
</div>
<a class="anchor" id="gab08dbf9b4f59eccae146764173c14659"></a><!-- doxytag: member="i2c_slave.h::I2C_SLAVE_STATUS_BUS_ERROR" ref="gab08dbf9b4f59eccae146764173c14659" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gab08dbf9b4f59eccae146764173c14659">I2C_SLAVE_STATUS_BUS_ERROR</a>&#160;&#160;&#160;(1UL &lt;&lt; 8)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Bus error. </p>

</div>
</div>
<a class="anchor" id="gad35c4a3d06b7dee73006f8fcc2583fc9"></a><!-- doxytag: member="i2c_slave.h::I2C_SLAVE_STATUS_CLOCK_HOLD" ref="gad35c4a3d06b7dee73006f8fcc2583fc9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gad35c4a3d06b7dee73006f8fcc2583fc9">I2C_SLAVE_STATUS_CLOCK_HOLD</a>&#160;&#160;&#160;(1UL &lt;&lt; 3)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clock Hold. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Cannot be cleared, only valid when I2C_SLAVE_STATUS_ADDRESS_MATCH is set. </dd></dl>

</div>
</div>
<a class="anchor" id="gab6303af78b1582ab1e20e9a9151acdd6"></a><!-- doxytag: member="i2c_slave.h::I2C_SLAVE_STATUS_COLLISION" ref="gab6303af78b1582ab1e20e9a9151acdd6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gab6303af78b1582ab1e20e9a9151acdd6">I2C_SLAVE_STATUS_COLLISION</a>&#160;&#160;&#160;(1UL &lt;&lt; 7)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Transmit Collision. </p>

</div>
</div>
<a class="anchor" id="gad51487f143d69d120529c2dc390704f8"></a><!-- doxytag: member="i2c_slave.h::I2C_SLAVE_STATUS_DATA_READY" ref="gad51487f143d69d120529c2dc390704f8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gad51487f143d69d120529c2dc390704f8">I2C_SLAVE_STATUS_DATA_READY</a>&#160;&#160;&#160;(1UL &lt;&lt; 1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Data Ready. </p>

</div>
</div>
<a class="anchor" id="ga914b5b47cfc5d49ee7aba3703a2c8e7a"></a><!-- doxytag: member="i2c_slave.h::I2C_SLAVE_STATUS_RECEIVED_NACK" ref="ga914b5b47cfc5d49ee7aba3703a2c8e7a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga914b5b47cfc5d49ee7aba3703a2c8e7a">I2C_SLAVE_STATUS_RECEIVED_NACK</a>&#160;&#160;&#160;(1UL &lt;&lt; 6)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Received not acknowledge. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Cannot be cleared. </dd></dl>

</div>
</div>
<a class="anchor" id="ga76abc9f40af15bfa050207bbf678f0dc"></a><!-- doxytag: member="i2c_slave.h::I2C_SLAVE_STATUS_REPEATED_START" ref="ga76abc9f40af15bfa050207bbf678f0dc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga76abc9f40af15bfa050207bbf678f0dc">I2C_SLAVE_STATUS_REPEATED_START</a>&#160;&#160;&#160;(1UL &lt;&lt; 5)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Repeated Start. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Cannot be cleared, only valid when I2C_SLAVE_STATUS_ADDRESS_MATCH is set. </dd></dl>

</div>
</div>
<a class="anchor" id="ga40dee3f12952a54efe2fba5c2231dee6"></a><!-- doxytag: member="i2c_slave.h::I2C_SLAVE_STATUS_SCL_LOW_TIMEOUT" ref="ga40dee3f12952a54efe2fba5c2231dee6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga40dee3f12952a54efe2fba5c2231dee6">I2C_SLAVE_STATUS_SCL_LOW_TIMEOUT</a>&#160;&#160;&#160;(1UL &lt;&lt; 4)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>SCL Low Timeout. </p>

</div>
</div>
<a class="anchor" id="ga801b54f4d3848901da67186733534b5a"></a><!-- doxytag: member="i2c_slave.h::I2C_SLAVE_STATUS_STOP_RECEIVED" ref="ga801b54f4d3848901da67186733534b5a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga801b54f4d3848901da67186733534b5a">I2C_SLAVE_STATUS_STOP_RECEIVED</a>&#160;&#160;&#160;(1UL &lt;&lt; 2)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stop Received. </p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gad1bf386f7d839c87db6421113488c1b2"></a><!-- doxytag: member="i2c_slave.h::i2c_slave_callback_t" ref="gad1bf386f7d839c87db6421113488c1b2" args=")(struct i2c_slave_module *const module)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gad1bf386f7d839c87db6421113488c1b2">i2c_slave_callback_t</a>)(struct <a class="el" href="structi2c__slave__module.html">i2c_slave_module</a> *const module)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Callback type. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="gace1e0023f2eee92565496a2e30006548"></a><!-- doxytag: member="i2c_master.h::i2c_master_baud_rate" ref="gace1e0023f2eee92565496a2e30006548" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gace1e0023f2eee92565496a2e30006548">i2c_master_baud_rate</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>I<sup>2</sup>C frequencies. </p>
<p>Values for I<sup>2</sup>C speeds supported by the module. The driver will also support setting any other value, in which case set the value in the <a class="el" href="structi2c__master__config.html">i2c_master_config</a> at desired value divided by 1000.</p>
<p>Example: If 10KHz operation is required, give baud_rate in the configuration structure the value 10. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggace1e0023f2eee92565496a2e30006548a24ddfbe034a690d3a553a17508cbd625"></a><!-- doxytag: member="I2C_MASTER_BAUD_RATE_100KHZ" ref="ggace1e0023f2eee92565496a2e30006548a24ddfbe034a690d3a553a17508cbd625" args="" -->I2C_MASTER_BAUD_RATE_100KHZ</em>&nbsp;</td><td>
<p>Baud rate at 100KHz (Standard-mode). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggace1e0023f2eee92565496a2e30006548a970dccbbc3dd1d01c1070db6d9aa24cb"></a><!-- doxytag: member="I2C_MASTER_BAUD_RATE_400KHZ" ref="ggace1e0023f2eee92565496a2e30006548a970dccbbc3dd1d01c1070db6d9aa24cb" args="" -->I2C_MASTER_BAUD_RATE_400KHZ</em>&nbsp;</td><td>
<p>Baud rate at 400KHz (Fast-mode). </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga844ac2694772642cfee08a29c50bf054"></a><!-- doxytag: member="i2c_master.h::i2c_master_callback" ref="ga844ac2694772642cfee08a29c50bf054" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga844ac2694772642cfee08a29c50bf054">i2c_master_callback</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback types. </p>
<p>The available callback types for the I<sup>2</sup>C master module. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga844ac2694772642cfee08a29c50bf054a37c3aab3ceb2bddf4b42672386fd64f2"></a><!-- doxytag: member="I2C_MASTER_CALLBACK_WRITE_COMPLETE" ref="gga844ac2694772642cfee08a29c50bf054a37c3aab3ceb2bddf4b42672386fd64f2" args="" -->I2C_MASTER_CALLBACK_WRITE_COMPLETE</em>&nbsp;</td><td>
<p>Callback for packet write complete. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga844ac2694772642cfee08a29c50bf054a64edbb1496288626e11b020a887ffcf8"></a><!-- doxytag: member="I2C_MASTER_CALLBACK_READ_COMPLETE" ref="gga844ac2694772642cfee08a29c50bf054a64edbb1496288626e11b020a887ffcf8" args="" -->I2C_MASTER_CALLBACK_READ_COMPLETE</em>&nbsp;</td><td>
<p>Callback for packet read complete. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga844ac2694772642cfee08a29c50bf054a97597905a886849275665273da79442f"></a><!-- doxytag: member="I2C_MASTER_CALLBACK_ERROR" ref="gga844ac2694772642cfee08a29c50bf054a97597905a886849275665273da79442f" args="" -->I2C_MASTER_CALLBACK_ERROR</em>&nbsp;</td><td>
<p>Callback for error. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga844ac2694772642cfee08a29c50bf054a3563390afb1b1b26a6252e0b5981ed06"></a><!-- doxytag: member="_I2C_MASTER_CALLBACK_N" ref="gga844ac2694772642cfee08a29c50bf054a3563390afb1b1b26a6252e0b5981ed06" args="" -->_I2C_MASTER_CALLBACK_N</em>&nbsp;</td><td>
<p>Total number of callbacks. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4640bee224bf835f4c38d7702be0742c"></a><!-- doxytag: member="i2c_master.h::i2c_master_inactive_timeout" ref="ga4640bee224bf835f4c38d7702be0742c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga4640bee224bf835f4c38d7702be0742c">i2c_master_inactive_timeout</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Values for inactive bus time-out. </p>
<p>If the inactive bus time-out is enabled and the bus is inactive for longer than the time-out setting, the bus state logic will be set to idle. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga4640bee224bf835f4c38d7702be0742ca52414c5127a26a6811f30324102cc3b1"></a><!-- doxytag: member="I2C_MASTER_INACTIVE_TIMEOUT_DISABLED" ref="gga4640bee224bf835f4c38d7702be0742ca52414c5127a26a6811f30324102cc3b1" args="" -->I2C_MASTER_INACTIVE_TIMEOUT_DISABLED</em>&nbsp;</td><td>
<p>Inactive bus time-out disabled. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga4640bee224bf835f4c38d7702be0742ca9e204c432b52e77b4d34a5b64d4432e9"></a><!-- doxytag: member="I2C_MASTER_INACTIVE_TIMEOUT_55US" ref="gga4640bee224bf835f4c38d7702be0742ca9e204c432b52e77b4d34a5b64d4432e9" args="" -->I2C_MASTER_INACTIVE_TIMEOUT_55US</em>&nbsp;</td><td>
<p>Inactive bus time-out 5-6 SCL cycle time-out. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga4640bee224bf835f4c38d7702be0742ca9f37beb962cccc4538b0c226c921c553"></a><!-- doxytag: member="I2C_MASTER_INACTIVE_TIMEOUT_105US" ref="gga4640bee224bf835f4c38d7702be0742ca9f37beb962cccc4538b0c226c921c553" args="" -->I2C_MASTER_INACTIVE_TIMEOUT_105US</em>&nbsp;</td><td>
<p>Inactive bus time-out 10-11 SCL cycle time-out. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga4640bee224bf835f4c38d7702be0742ca7412f98fd47572a75dc17727fdf735d0"></a><!-- doxytag: member="I2C_MASTER_INACTIVE_TIMEOUT_205US" ref="gga4640bee224bf835f4c38d7702be0742ca7412f98fd47572a75dc17727fdf735d0" args="" -->I2C_MASTER_INACTIVE_TIMEOUT_205US</em>&nbsp;</td><td>
<p>Inactive bus time-out 20-21 SCL cycle time-out. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9f73c4fbd225704c2e0da23319c25555"></a><!-- doxytag: member="i2c_master.h::i2c_master_interrupt_flag" ref="ga9f73c4fbd225704c2e0da23319c25555" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga9f73c4fbd225704c2e0da23319c25555">i2c_master_interrupt_flag</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Interrupt flags. </p>
<p>Flags used when reading or setting interrupt flags. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga9f73c4fbd225704c2e0da23319c25555a39c138d5f063f3d43b4e974870364d2e"></a><!-- doxytag: member="I2C_MASTER_INTERRUPT_WRITE" ref="gga9f73c4fbd225704c2e0da23319c25555a39c138d5f063f3d43b4e974870364d2e" args="" -->I2C_MASTER_INTERRUPT_WRITE</em>&nbsp;</td><td>
<p>Interrupt flag used for write. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga9f73c4fbd225704c2e0da23319c25555a3087032aa3a5218a0cdc54179d9e1d09"></a><!-- doxytag: member="I2C_MASTER_INTERRUPT_READ" ref="gga9f73c4fbd225704c2e0da23319c25555a3087032aa3a5218a0cdc54179d9e1d09" args="" -->I2C_MASTER_INTERRUPT_READ</em>&nbsp;</td><td>
<p>Interrupt flag used for read. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gadd8aa7cabbddc1cd2c1a8753c9b99d20"></a><!-- doxytag: member="i2c_master.h::i2c_master_start_hold_time" ref="gadd8aa7cabbddc1cd2c1a8753c9b99d20" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gadd8aa7cabbddc1cd2c1a8753c9b99d20">i2c_master_start_hold_time</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Values for hold time after start bit. </p>
<p>Values for the possible I<sup>2</sup>C master mode SDA internal hold times after start bit has been sent. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggadd8aa7cabbddc1cd2c1a8753c9b99d20a85f0b592eef5f8b5ecae9f2cca2d4cd1"></a><!-- doxytag: member="I2C_MASTER_START_HOLD_TIME_DISABLED" ref="ggadd8aa7cabbddc1cd2c1a8753c9b99d20a85f0b592eef5f8b5ecae9f2cca2d4cd1" args="" -->I2C_MASTER_START_HOLD_TIME_DISABLED</em>&nbsp;</td><td>
<p>Internal SDA hold time disabled. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggadd8aa7cabbddc1cd2c1a8753c9b99d20a41403c4a18a1220f031c99e52f384e39"></a><!-- doxytag: member="I2C_MASTER_START_HOLD_TIME_50NS_100NS" ref="ggadd8aa7cabbddc1cd2c1a8753c9b99d20a41403c4a18a1220f031c99e52f384e39" args="" -->I2C_MASTER_START_HOLD_TIME_50NS_100NS</em>&nbsp;</td><td>
<p>Internal SDA hold time 50ns - 100ns. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggadd8aa7cabbddc1cd2c1a8753c9b99d20acc3f7849862510590acc2e3bebc29d0c"></a><!-- doxytag: member="I2C_MASTER_START_HOLD_TIME_300NS_600NS" ref="ggadd8aa7cabbddc1cd2c1a8753c9b99d20acc3f7849862510590acc2e3bebc29d0c" args="" -->I2C_MASTER_START_HOLD_TIME_300NS_600NS</em>&nbsp;</td><td>
<p>Internal SDA hold time 300ns - 600ns. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggadd8aa7cabbddc1cd2c1a8753c9b99d20a38cf380ace8d180528eb34bc38b7da9e"></a><!-- doxytag: member="I2C_MASTER_START_HOLD_TIME_400NS_800NS" ref="ggadd8aa7cabbddc1cd2c1a8753c9b99d20a38cf380ace8d180528eb34bc38b7da9e" args="" -->I2C_MASTER_START_HOLD_TIME_400NS_800NS</em>&nbsp;</td><td>
<p>Internal SDA hold time 400ns - 800ns. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gadbcbd4ca061dd80196ce37aeed5eec87"></a><!-- doxytag: member="i2c_slave.h::i2c_slave_address_mode" ref="gadbcbd4ca061dd80196ce37aeed5eec87" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gadbcbd4ca061dd80196ce37aeed5eec87">i2c_slave_address_mode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enum for the possible address modes. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggadbcbd4ca061dd80196ce37aeed5eec87a4f9748991dfdca99901a21920f41c2d5"></a><!-- doxytag: member="I2C_SLAVE_ADDRESS_MODE_MASK" ref="ggadbcbd4ca061dd80196ce37aeed5eec87a4f9748991dfdca99901a21920f41c2d5" args="" -->I2C_SLAVE_ADDRESS_MODE_MASK</em>&nbsp;</td><td>
<p>Address match on address_mask used as a mask to address. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggadbcbd4ca061dd80196ce37aeed5eec87abd5fecb8a7003ce607199143aab45eff"></a><!-- doxytag: member="I2C_SLAVE_ADDRESS_MODE_TWO_ADDRESSES" ref="ggadbcbd4ca061dd80196ce37aeed5eec87abd5fecb8a7003ce607199143aab45eff" args="" -->I2C_SLAVE_ADDRESS_MODE_TWO_ADDRESSES</em>&nbsp;</td><td>
<p>Address math on both address and address_mask. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggadbcbd4ca061dd80196ce37aeed5eec87aba4ec9aa23be4e24902b642738d53247"></a><!-- doxytag: member="I2C_SLAVE_ADDRESS_MODE_RANGE" ref="ggadbcbd4ca061dd80196ce37aeed5eec87aba4ec9aa23be4e24902b642738d53247" args="" -->I2C_SLAVE_ADDRESS_MODE_RANGE</em>&nbsp;</td><td>
<p>Address match on range of addresses between and including address and address_mask. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga90235bfca166d527fba19fe230475a14"></a><!-- doxytag: member="i2c_slave.h::i2c_slave_callback" ref="ga90235bfca166d527fba19fe230475a14" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga90235bfca166d527fba19fe230475a14">i2c_slave_callback</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback types. </p>
<p>The available callback types for the I<sup>2</sup>C slave. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga90235bfca166d527fba19fe230475a14aa9c97e1fc8a197338d5b4cd4998c5b94"></a><!-- doxytag: member="I2C_SLAVE_CALLBACK_WRITE_COMPLETE" ref="gga90235bfca166d527fba19fe230475a14aa9c97e1fc8a197338d5b4cd4998c5b94" args="" -->I2C_SLAVE_CALLBACK_WRITE_COMPLETE</em>&nbsp;</td><td>
<p>Callback for packet write complete. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga90235bfca166d527fba19fe230475a14ad4ea2cf32f73781d19a113e8ede05523"></a><!-- doxytag: member="I2C_SLAVE_CALLBACK_READ_COMPLETE" ref="gga90235bfca166d527fba19fe230475a14ad4ea2cf32f73781d19a113e8ede05523" args="" -->I2C_SLAVE_CALLBACK_READ_COMPLETE</em>&nbsp;</td><td>
<p>Callback for packet read complete. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga90235bfca166d527fba19fe230475a14a284f6a1b843168f5ec6fe9a2ae1f7a92"></a><!-- doxytag: member="I2C_SLAVE_CALLBACK_READ_REQUEST" ref="gga90235bfca166d527fba19fe230475a14a284f6a1b843168f5ec6fe9a2ae1f7a92" args="" -->I2C_SLAVE_CALLBACK_READ_REQUEST</em>&nbsp;</td><td>
<p>Callback for read request from master - can be used to issue a write. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga90235bfca166d527fba19fe230475a14a0c29d5624ede1c4f3d7a1ba08350a4bc"></a><!-- doxytag: member="I2C_SLAVE_CALLBACK_WRITE_REQUEST" ref="gga90235bfca166d527fba19fe230475a14a0c29d5624ede1c4f3d7a1ba08350a4bc" args="" -->I2C_SLAVE_CALLBACK_WRITE_REQUEST</em>&nbsp;</td><td>
<p>Callback for write request from master - can be used to issue a read. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga90235bfca166d527fba19fe230475a14aebef553e929b1169ba9d1278e190279c"></a><!-- doxytag: member="I2C_SLAVE_CALLBACK_ERROR" ref="gga90235bfca166d527fba19fe230475a14aebef553e929b1169ba9d1278e190279c" args="" -->I2C_SLAVE_CALLBACK_ERROR</em>&nbsp;</td><td>
<p>Callback for error. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga90235bfca166d527fba19fe230475a14affe940500251691e9cd032c050bcd5bc"></a><!-- doxytag: member="I2C_SLAVE_CALLBACK_ERROR_LAST_TRANSFER" ref="gga90235bfca166d527fba19fe230475a14affe940500251691e9cd032c050bcd5bc" args="" -->I2C_SLAVE_CALLBACK_ERROR_LAST_TRANSFER</em>&nbsp;</td><td>
<p>Callback for error in last transfer. Discovered on a new address interrupt. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga90235bfca166d527fba19fe230475a14afbf34deacc91b2dbe2108c4fc51ad975"></a><!-- doxytag: member="_I2C_SLAVE_CALLBACK_N" ref="gga90235bfca166d527fba19fe230475a14afbf34deacc91b2dbe2108c4fc51ad975" args="" -->_I2C_SLAVE_CALLBACK_N</em>&nbsp;</td><td>
<p>Total number of callbacks. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gac9afde0120288a8a42cb3b1dc6594cc6"></a><!-- doxytag: member="i2c_slave.h::i2c_slave_direction" ref="gac9afde0120288a8a42cb3b1dc6594cc6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gac9afde0120288a8a42cb3b1dc6594cc6">i2c_slave_direction</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enum for the direction of a request. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggac9afde0120288a8a42cb3b1dc6594cc6aee5e40bb4e1283ac7bb3f7ab926f1006"></a><!-- doxytag: member="I2C_SLAVE_DIRECTION_READ" ref="ggac9afde0120288a8a42cb3b1dc6594cc6aee5e40bb4e1283ac7bb3f7ab926f1006" args="" -->I2C_SLAVE_DIRECTION_READ</em>&nbsp;</td><td>
<p>Read. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggac9afde0120288a8a42cb3b1dc6594cc6a7ad9455bf2e71899dbd12ea1c2893708"></a><!-- doxytag: member="I2C_SLAVE_DIRECTION_WRITE" ref="ggac9afde0120288a8a42cb3b1dc6594cc6a7ad9455bf2e71899dbd12ea1c2893708" args="" -->I2C_SLAVE_DIRECTION_WRITE</em>&nbsp;</td><td>
<p>Write. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggac9afde0120288a8a42cb3b1dc6594cc6a8eeec94989a66ecb30219353ef1b3456"></a><!-- doxytag: member="I2C_SLAVE_DIRECTION_NONE" ref="ggac9afde0120288a8a42cb3b1dc6594cc6a8eeec94989a66ecb30219353ef1b3456" args="" -->I2C_SLAVE_DIRECTION_NONE</em>&nbsp;</td><td>
<p>No direction. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga81c9919ecf8f0eab59841a6168969d7c"></a><!-- doxytag: member="i2c_slave.h::i2c_slave_sda_hold_time" ref="ga81c9919ecf8f0eab59841a6168969d7c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga81c9919ecf8f0eab59841a6168969d7c">i2c_slave_sda_hold_time</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enum for the possible SDA hold times with respect to the negative edge of SCL. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga81c9919ecf8f0eab59841a6168969d7ca490e60c6bb9abe06173e7edfcb512809"></a><!-- doxytag: member="I2C_SLAVE_SDA_HOLD_TIME_DISABLED" ref="gga81c9919ecf8f0eab59841a6168969d7ca490e60c6bb9abe06173e7edfcb512809" args="" -->I2C_SLAVE_SDA_HOLD_TIME_DISABLED</em>&nbsp;</td><td>
<p>SDA hold time disabled. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga81c9919ecf8f0eab59841a6168969d7cab7eb05387febe74423129d3a4b6ac411"></a><!-- doxytag: member="I2C_SLAVE_SDA_HOLD_TIME_50NS_100NS" ref="gga81c9919ecf8f0eab59841a6168969d7cab7eb05387febe74423129d3a4b6ac411" args="" -->I2C_SLAVE_SDA_HOLD_TIME_50NS_100NS</em>&nbsp;</td><td>
<p>SDA hold time 50ns - 100ns. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga81c9919ecf8f0eab59841a6168969d7ca7a5d0d4bd995f0118aec5b8bb095eb96"></a><!-- doxytag: member="I2C_SLAVE_SDA_HOLD_TIME_300NS_600NS" ref="gga81c9919ecf8f0eab59841a6168969d7ca7a5d0d4bd995f0118aec5b8bb095eb96" args="" -->I2C_SLAVE_SDA_HOLD_TIME_300NS_600NS</em>&nbsp;</td><td>
<p>SDA hold time 300ns - 600ns. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga81c9919ecf8f0eab59841a6168969d7cab2adc4496b7f8bcd36520953fd7d1de3"></a><!-- doxytag: member="I2C_SLAVE_SDA_HOLD_TIME_400NS_800NS" ref="gga81c9919ecf8f0eab59841a6168969d7cab2adc4496b7f8bcd36520953fd7d1de3" args="" -->I2C_SLAVE_SDA_HOLD_TIME_400NS_800NS</em>&nbsp;</td><td>
<p>SDA hold time 400ns - 800ns. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu Jun 23 2016 20:43:16 for Atmel Radio by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>

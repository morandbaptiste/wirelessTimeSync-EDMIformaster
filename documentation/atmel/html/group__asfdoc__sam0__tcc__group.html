<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Atmel Radio: SAM Timer Counter for Control Applications Driver (TCC)</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Atmel Radio
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SAM Timer Counter for Control Applications Driver (TCC)</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtcc__recoverable__fault__config.html">tcc_recoverable_fault_config</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration struct for TCC module recoverable fault.  <a href="structtcc__recoverable__fault__config.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtcc__non__recoverable__fault__config.html">tcc_non_recoverable_fault_config</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration struct for TCC module non-recoverable fault.  <a href="structtcc__non__recoverable__fault__config.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtcc__input__event__config.html">tcc_input_event_config</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCC input event enable/disable/configure structure.  <a href="structtcc__input__event__config.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtcc__output__event__config.html">tcc_output_event_config</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCC output event enable/disable/configure structure.  <a href="structtcc__output__event__config.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtcc__events.html">tcc_events</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCC event enable/disable structure.  <a href="structtcc__events.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtcc__counter__config.html">tcc_counter_config</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration struct for the TCC module base counter.  <a href="structtcc__counter__config.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtcc__capture__config.html">tcc_capture_config</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration struct for the TCC module capture.  <a href="structtcc__capture__config.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtcc__match__wave__config.html">tcc_match_wave_config</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration struct for the TCC module match/wave generation.  <a href="structtcc__match__wave__config.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtcc__wave__extension__config.html">tcc_wave_extension_config</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration struct for the TCC module waveform extension.  <a href="structtcc__wave__extension__config.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtcc__pins__config.html">tcc_pins_config</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration struct for the TCC module output pins.  <a href="structtcc__pins__config.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtcc__config.html">tcc_config</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCC configuration structure.  <a href="structtcc__config.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtcc__module.html">tcc_module</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCC software device instance structure.  <a href="structtcc__module.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#ga06877478c8a906a198f6deae11158bfb">TCC_NUM_CHANNELS</a>&#160;&#160;&#160;4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#ga7b57a63497d3b7c055b3f9abc876b719">TCC_NUM_WAVE_OUTPUTS</a>&#160;&#160;&#160;8</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#ga1272407779618185ec6492c78db1c493">TCC_NUM_FAULTS</a>&#160;&#160;&#160;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#ga2fd9e1a57cd1951880c3d5c844463e62">_TCC_ENUM</a>(n, type)&#160;&#160;&#160;TCC_##type##_##n,</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga86d077c6c357d64895589f0c8bb6473e"></a><!-- doxytag: member="asfdoc_sam0_tcc_group::_TCC_CHANNEL_ENUM_LIST" ref="ga86d077c6c357d64895589f0c8bb6473e" args="(type)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>_TCC_CHANNEL_ENUM_LIST</b>(type)&#160;&#160;&#160;<a class="el" href="group__group__sam0__utils__mrepeat.html#ga42db715ccb877ca87d7903f5783bd104">MREPEAT</a>(<a class="el" href="group__asfdoc__sam0__tcc__group.html#ga06877478c8a906a198f6deae11158bfb">TCC_NUM_CHANNELS</a>, <a class="el" href="group__asfdoc__sam0__tcc__group.html#ga2fd9e1a57cd1951880c3d5c844463e62">_TCC_ENUM</a>, type##_CHANNEL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga061ae9eaf6dd5fbf4fd3185075819bf1"></a><!-- doxytag: member="asfdoc_sam0_tcc_group::_TCC_WO_ENUM_LIST" ref="ga061ae9eaf6dd5fbf4fd3185075819bf1" args="(type)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>_TCC_WO_ENUM_LIST</b>(type)&#160;&#160;&#160;<a class="el" href="group__group__sam0__utils__mrepeat.html#ga42db715ccb877ca87d7903f5783bd104">MREPEAT</a>(<a class="el" href="group__asfdoc__sam0__tcc__group.html#ga7b57a63497d3b7c055b3f9abc876b719">TCC_NUM_WAVE_OUTPUTS</a>, <a class="el" href="group__asfdoc__sam0__tcc__group.html#ga2fd9e1a57cd1951880c3d5c844463e62">_TCC_ENUM</a>, type)</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#gaa7b829de23a325cdf88764fb0d1f6994">tcc_callback_t</a> )(struct <a class="el" href="structtcc__module.html">tcc_module</a> *const module)</td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#ga36a7de76e8e93ecbeae82cd5667e2eeb">tcc_callback</a> { <br/>
&#160;&#160;<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga36a7de76e8e93ecbeae82cd5667e2eeba6b9667d1969eae897e336f13055ec6f2">TCC_CALLBACK_OVERFLOW</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga36a7de76e8e93ecbeae82cd5667e2eeba442e3a9a1d11d76b2a4c060cf45dd8d4">TCC_CALLBACK_RETRIGGER</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga36a7de76e8e93ecbeae82cd5667e2eeba835f3af607d0e16468b7c0099163ab27">TCC_CALLBACK_COUNTER_EVENT</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga36a7de76e8e93ecbeae82cd5667e2eeba73b9585a99ef2d625aa21cc4ecedff9c">TCC_CALLBACK_ERROR</a>, 
<br/>
&#160;&#160;<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga36a7de76e8e93ecbeae82cd5667e2eeba338a3e176a8c4be2596143c7f065acf8">TCC_CALLBACK_FAULTA</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga36a7de76e8e93ecbeae82cd5667e2eeba38e46ea2ee82304f054b0536cc3d90b8">TCC_CALLBACK_FAULTB</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga36a7de76e8e93ecbeae82cd5667e2eeba98ceac9bcd0c20f4ed17d89d65ab79c2">TCC_CALLBACK_FAULT0</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga36a7de76e8e93ecbeae82cd5667e2eeba0aa610b809e86ad1c813aeaa70691ea1">TCC_CALLBACK_FAULT1</a>, 
<br/>
&#160;&#160;<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga36a7de76e8e93ecbeae82cd5667e2eebafc4efa0a3bbb81182756228f3bc1b972">TCC_CALLBACK_N</a>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#gaf0ea531eacd92224d87ebdaf63db6c86">tcc_match_capture_channel</a> { <a class="el" href="group__asfdoc__sam0__tcc__group.html#ggaf0ea531eacd92224d87ebdaf63db6c86af731a3af6f1bf07648bfe3b632be6706">TCC_MATCH_CAPTURE_CHANNEL_N</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the match capture channels.  <a href="group__asfdoc__sam0__tcc__group.html#gaf0ea531eacd92224d87ebdaf63db6c86">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#ga94e085112cc19e5704a40ac7f339b93e">tcc_wave_output</a> { <a class="el" href="group__asfdoc__sam0__tcc__group.html#gga94e085112cc19e5704a40ac7f339b93ea27b309a1d5d9b4068806365d900b839c">TCC_WAVE_OUTPUT_N</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the wave outputs.  <a href="group__asfdoc__sam0__tcc__group.html#ga94e085112cc19e5704a40ac7f339b93e">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#ga17089c430302f3def00bc4cfa2176c64">tcc_wave_generation</a> { <br/>
&#160;&#160;<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga17089c430302f3def00bc4cfa2176c64adc633542224dc2dd60668814c200b856">TCC_WAVE_GENERATION_NORMAL_FREQ</a> =  0, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga17089c430302f3def00bc4cfa2176c64a2b290ae1f45d8e342aad437bd1d9c9aa">TCC_WAVE_GENERATION_MATCH_FREQ</a> =  1, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga17089c430302f3def00bc4cfa2176c64a410425079bb54c0cce5f385ff01e66dc">TCC_WAVE_GENERATION_SINGLE_SLOPE_PWM</a> =  2, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga17089c430302f3def00bc4cfa2176c64add7608a724c8c655a6338749e9259152">TCC_WAVE_GENERATION_DOUBLE_SLOPE_CRITICAL</a> =  4, 
<br/>
&#160;&#160;<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga17089c430302f3def00bc4cfa2176c64aec68f47d4983be9e906e1311f8dd59f1">TCC_WAVE_GENERATION_DOUBLE_SLOPE_BOTTOM</a> =  5, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga17089c430302f3def00bc4cfa2176c64ad6b23beb050085088c72b5fd81c43e96">TCC_WAVE_GENERATION_DOUBLE_SLOPE_BOTH</a> =  6, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga17089c430302f3def00bc4cfa2176c64a92f114fb43174f1b917757808fa634b8">TCC_WAVE_GENERATION_DOUBLE_SLOPE_TOP</a> =  7
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCC wave generation mode enum.  <a href="group__asfdoc__sam0__tcc__group.html#ga17089c430302f3def00bc4cfa2176c64">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#ga30b821497239e10c9d05d457517ae660">tcc_wave_polarity</a> { <a class="el" href="group__asfdoc__sam0__tcc__group.html#gga30b821497239e10c9d05d457517ae660a86b9b44a2c9e6629f23c6cba7ca9dd66">TCC_WAVE_POLARITY_0</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga30b821497239e10c9d05d457517ae660a1a1df87b86653af7e20451f66d12b072">TCC_WAVE_POLARITY_1</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Polarity of TCC wave generation on channels.  <a href="group__asfdoc__sam0__tcc__group.html#ga30b821497239e10c9d05d457517ae660">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#gae308e9eeb120db42f773f680118fe340">tcc_output_pattern</a> { <a class="el" href="group__asfdoc__sam0__tcc__group.html#ggae308e9eeb120db42f773f680118fe340a0f4c63e8ade521fd775b593432395522">TCC_OUTPUT_PATTERN_DISABLE</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggae308e9eeb120db42f773f680118fe340ac6a635e4d036e7d6fda1f0a523662a3e">TCC_OUTPUT_PATTERN_0</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggae308e9eeb120db42f773f680118fe340a1495634d6a9e8921522886b67e29624c">TCC_OUTPUT_PATTERN_1</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCC pattern generator for outputs.  <a href="group__asfdoc__sam0__tcc__group.html#gae308e9eeb120db42f773f680118fe340">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#ga34e5c70c51742be434fb76aee0e9efdb">tcc_ramp</a> { <a class="el" href="group__asfdoc__sam0__tcc__group.html#gga34e5c70c51742be434fb76aee0e9efdbaac8e00b72dd45b706c20d22d4d82a608">TCC_RAMP_RAMP1</a> =  0, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga34e5c70c51742be434fb76aee0e9efdba70b3f4234e9ce2d0a686332d1585b907">TCC_RAMP_RAMP2A</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga34e5c70c51742be434fb76aee0e9efdba14a8cca97df1ae7a4a17382a2ae95fca">TCC_RAMP_RAMP2</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ramp Operations which are supported in single-slope PWM generation.  <a href="group__asfdoc__sam0__tcc__group.html#ga34e5c70c51742be434fb76aee0e9efdb">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#ga00764af4bfa719981b2a4f6e224dd9c1">tcc_ramp_index</a> { <a class="el" href="group__asfdoc__sam0__tcc__group.html#gga00764af4bfa719981b2a4f6e224dd9c1afd3b9a8e71c199b3658b1083af2a5380">TCC_RAMP_INDEX_DEFAULT</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga00764af4bfa719981b2a4f6e224dd9c1ae76a5e98f57968d2dcef6dbd5bf3c90a">TCC_RAMP_INDEX_FORCE_B</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga00764af4bfa719981b2a4f6e224dd9c1a5b5b5381abb1f7b13e9f8bb3d1485d18">TCC_RAMP_INDEX_FORCE_A</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga00764af4bfa719981b2a4f6e224dd9c1a5feec9212992528dcd589196f7a870e0">TCC_RAMP_INDEX_FORCE_KEEP</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ramp Index for TCC wave generation.  <a href="group__asfdoc__sam0__tcc__group.html#ga00764af4bfa719981b2a4f6e224dd9c1">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#ga91a7590776909b314bf8b2d380db25f2">tcc_output_invertion</a> { <a class="el" href="group__asfdoc__sam0__tcc__group.html#gga91a7590776909b314bf8b2d380db25f2a82021056838ce19baddfa2c26cbf7928">TCC_OUTPUT_INVERTION_DISABLE</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga91a7590776909b314bf8b2d380db25f2a19d555910cf6a29718737f5f5391d7de">TCC_OUTPUT_INVERTION_ENABLE</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCC output inversion.  <a href="group__asfdoc__sam0__tcc__group.html#ga91a7590776909b314bf8b2d380db25f2">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#ga264546e2899d650a7028f6947dbac213">tcc_reload_action</a> { <a class="el" href="group__asfdoc__sam0__tcc__group.html#gga264546e2899d650a7028f6947dbac213a670a06c074cc1472b0beca70288d4736">TCC_RELOAD_ACTION_GCLK</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga264546e2899d650a7028f6947dbac213adb1a11b156b6046d7160867575b0ab07">TCC_RELOAD_ACTION_PRESC</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga264546e2899d650a7028f6947dbac213a8428201f62b949440e8c63fe458e0fc0">TCC_RELOAD_ACTION_RESYNC</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCC Counter reload action enum.  <a href="group__asfdoc__sam0__tcc__group.html#ga264546e2899d650a7028f6947dbac213">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#ga70c3b34ad991069c634a97ec61f52edf">tcc_clock_prescaler</a> { <br/>
&#160;&#160;<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga70c3b34ad991069c634a97ec61f52edfab732d492f2700d8937404d6c445008ac">TCC_CLOCK_PRESCALER_DIV1</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga70c3b34ad991069c634a97ec61f52edfa4fa7cd62d909645db98258cfc8748c4d">TCC_CLOCK_PRESCALER_DIV2</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga70c3b34ad991069c634a97ec61f52edfac52a69742c42f464bc86612e006155a9">TCC_CLOCK_PRESCALER_DIV4</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga70c3b34ad991069c634a97ec61f52edfa0c888826e7d29861159e56fa300d88e5">TCC_CLOCK_PRESCALER_DIV8</a>, 
<br/>
&#160;&#160;<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga70c3b34ad991069c634a97ec61f52edfa10870a7304fc7b7466d8af1f2c777145">TCC_CLOCK_PRESCALER_DIV16</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga70c3b34ad991069c634a97ec61f52edfa534a7c3281d31757b70135326a02dfe6">TCC_CLOCK_PRESCALER_DIV64</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga70c3b34ad991069c634a97ec61f52edfabd31ef941537f7c3f31c75554914f03f">TCC_CLOCK_PRESCALER_DIV256</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga70c3b34ad991069c634a97ec61f52edfad8d476a749f1a437da36ec9111ac9728">TCC_CLOCK_PRESCALER_DIV1024</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCC clock prescaler values.  <a href="group__asfdoc__sam0__tcc__group.html#ga70c3b34ad991069c634a97ec61f52edf">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#ga249b126aed3c60fdbc0e5d00c7174c3c">tcc_count_direction</a> { <a class="el" href="group__asfdoc__sam0__tcc__group.html#gga249b126aed3c60fdbc0e5d00c7174c3ca3b1fd4ef15ab404e4d2fc37b1761e807">TCC_COUNT_DIRECTION_UP</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga249b126aed3c60fdbc0e5d00c7174c3cab59c7a276ce88cfcfde916c982170492">TCC_COUNT_DIRECTION_DOWN</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCC module count direction.  <a href="group__asfdoc__sam0__tcc__group.html#ga249b126aed3c60fdbc0e5d00c7174c3c">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#gaaa34ddec58a743f0b079ed882bd7fa02">tcc_event_action</a> { <br/>
&#160;&#160;<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggaaa34ddec58a743f0b079ed882bd7fa02af05ae1f179159ae33abbf1637183d6dc">TCC_EVENT_ACTION_OFF</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggaaa34ddec58a743f0b079ed882bd7fa02a346ce4e970f712a026be939342dc92b7">TCC_EVENT_ACTION_STOP</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggaaa34ddec58a743f0b079ed882bd7fa02a64e6b5c1baa9d4e718c40e3be753406e">TCC_EVENT_ACTION_RETRIGGER</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggaaa34ddec58a743f0b079ed882bd7fa02a40edb508b1059e53e9eeb787810c2f51">TCC_EVENT_ACTION_START</a>, 
<br/>
&#160;&#160;<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggaaa34ddec58a743f0b079ed882bd7fa02a15216a830e8a5c495bef4fc088fc25df">TCC_EVENT_ACTION_COUNT_EVENT</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggaaa34ddec58a743f0b079ed882bd7fa02ac6a9f1ee37929a715d5010431b9836d4">TCC_EVENT_ACTION_DIR_CONTROL</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggaaa34ddec58a743f0b079ed882bd7fa02a8a2b0db66b4f0614b3c87e4e1f7e0c14">TCC_EVENT_ACTION_INCREMENT</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggaaa34ddec58a743f0b079ed882bd7fa02aeb1f6b4fcedd8dc68f0817ec55176b41">TCC_EVENT_ACTION_DECREMENT</a>, 
<br/>
&#160;&#160;<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggaaa34ddec58a743f0b079ed882bd7fa02a5c474138a0666f6c0f5bbc93a9f01d80">TCC_EVENT_ACTION_COUNT_DURING_ACTIVE</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggaaa34ddec58a743f0b079ed882bd7fa02a72631c0be6ff182cf0123de1f1512a25">TCC_EVENT_ACTION_PERIOD_PULSE_WIDTH_CAPTURE</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggaaa34ddec58a743f0b079ed882bd7fa02afa2722b2a4fe7638622116dff3e5316d">TCC_EVENT_ACTION_PULSE_WIDTH_PERIOD_CAPTURE</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggaaa34ddec58a743f0b079ed882bd7fa02a820646e92211693414a7a4e740510bb4">TCC_EVENT_ACTION_NON_RECOVERABLE_FAULT</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Action to perform when the TCC module is triggered by events.  <a href="group__asfdoc__sam0__tcc__group.html#gaaa34ddec58a743f0b079ed882bd7fa02">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#gad80cffdb90328129cfa1917a5bb9c61d">tcc_event0_action</a> { <br/>
&#160;&#160;<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggad80cffdb90328129cfa1917a5bb9c61da388276277ff792915d1017a5950bfb89">TCC_EVENT0_ACTION_OFF</a> =  TCC_EVENT_ACTION_OFF, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggad80cffdb90328129cfa1917a5bb9c61da984f4ad2899f9371cf7b81d73b254d3a">TCC_EVENT0_ACTION_RETRIGGER</a> =  TCC_EVENT_ACTION_RETRIGGER, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggad80cffdb90328129cfa1917a5bb9c61da87cfff8a1fd08029c4fdd8b0c70ef3d4">TCC_EVENT0_ACTION_COUNT_EVENT</a> =  TCC_EVENT_ACTION_COUNT_EVENT, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggad80cffdb90328129cfa1917a5bb9c61daaec5901deb6a5d2ed371d7233a21fefb">TCC_EVENT0_ACTION_START</a> =  TCC_EVENT_ACTION_START, 
<br/>
&#160;&#160;<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggad80cffdb90328129cfa1917a5bb9c61dab6237e36679539d6d99b7ea0046a3d98">TCC_EVENT0_ACTION_INCREMENT</a> =  TCC_EVENT_ACTION_INCREMENT, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggad80cffdb90328129cfa1917a5bb9c61da3da94c0377525cde8defc0885cb18774">TCC_EVENT0_ACTION_COUNT_DURING_ACTIVE</a> =  TCC_EVENT_ACTION_COUNT_DURING_ACTIVE, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggad80cffdb90328129cfa1917a5bb9c61da3a5f2eff577244d7abb31e5f374fb94b">TCC_EVENT0_ACTION_NON_RECOVERABLE_FAULT</a> =  TCC_EVENT_ACTION_NON_RECOVERABLE_FAULT
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Action to be performed when the TCC module is triggered by event0.  <a href="group__asfdoc__sam0__tcc__group.html#gad80cffdb90328129cfa1917a5bb9c61d">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#gae28fca3e41f8f09bf573ff0e5a50f9c8">tcc_event1_action</a> { <br/>
&#160;&#160;<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggae28fca3e41f8f09bf573ff0e5a50f9c8afdbcee9dd58cc27696b927c886196fd2">TCC_EVENT1_ACTION_OFF</a> =  TCC_EVENT_ACTION_OFF, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggae28fca3e41f8f09bf573ff0e5a50f9c8a13bb806d58d333a04dd20aae106d8e41">TCC_EVENT1_ACTION_RETRIGGER</a> =  TCC_EVENT_ACTION_RETRIGGER, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggae28fca3e41f8f09bf573ff0e5a50f9c8a7355f5535011ffa4a30e44c8da4a75a7">TCC_EVENT1_ACTION_DIR_CONTROL</a> =  TCC_EVENT_ACTION_DIR_CONTROL, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggae28fca3e41f8f09bf573ff0e5a50f9c8a7c326e29775ec2c6f25bb4ecab92d7d2">TCC_EVENT1_ACTION_STOP</a> =  TCC_EVENT_ACTION_STOP, 
<br/>
&#160;&#160;<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggae28fca3e41f8f09bf573ff0e5a50f9c8af03c20ad157070ed59c09a285e5d55dd">TCC_EVENT1_ACTION_DECREMENT</a> =  TCC_EVENT_ACTION_DECREMENT, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggae28fca3e41f8f09bf573ff0e5a50f9c8ac2303c6c7c2769c465212982dc52fd02">TCC_EVENT1_ACTION_PERIOD_PULSE_WIDTH_CAPTURE</a> =  TCC_EVENT_ACTION_PERIOD_PULSE_WIDTH_CAPTURE, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggae28fca3e41f8f09bf573ff0e5a50f9c8a94654078df98319b89a1548e7cdcbd56">TCC_EVENT1_ACTION_PULSE_WIDTH_PERIOD_CAPTURE</a> =  TCC_EVENT_ACTION_PULSE_WIDTH_PERIOD_CAPTURE, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggae28fca3e41f8f09bf573ff0e5a50f9c8a9b52632f222313ee66ee042423a6d846">TCC_EVENT1_ACTION_NON_RECOVERABLE_FAULT</a> =  TCC_EVENT_ACTION_NON_RECOVERABLE_FAULT
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Action to perform when the TCC module is triggered by event1.  <a href="group__asfdoc__sam0__tcc__group.html#gae28fca3e41f8f09bf573ff0e5a50f9c8">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#gae5d84230d25f8a38f2fb420fb9480383">tcc_event_generation_selection</a> { <a class="el" href="group__asfdoc__sam0__tcc__group.html#ggae5d84230d25f8a38f2fb420fb9480383a888a715219e4a10865a8dbb13e6dc4da">TCC_EVENT_GENERATION_SELECTION_START</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggae5d84230d25f8a38f2fb420fb9480383a09be4a3bc53fff81d9bf5d8333204540">TCC_EVENT_GENERATION_SELECTION_END</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggae5d84230d25f8a38f2fb420fb9480383aafe4aada27c0d416d4190d726b49c964">TCC_EVENT_GENERATION_SELECTION_BETWEEN</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggae5d84230d25f8a38f2fb420fb9480383a1cbde3ae103e3093714fbf63b70b3435">TCC_EVENT_GENERATION_SELECTION_BOUNDARY</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">On which part of the counter cycle the counter event output is generated.  <a href="group__asfdoc__sam0__tcc__group.html#gae5d84230d25f8a38f2fb420fb9480383">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#gaeaa625722173a7f2d75ac1356e8ae840">tcc_channel_function</a> { <a class="el" href="group__asfdoc__sam0__tcc__group.html#ggaeaa625722173a7f2d75ac1356e8ae840a77ef0541a43c84c80a56d26af06f3813">TCC_CHANNEL_FUNCTION_COMPARE</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggaeaa625722173a7f2d75ac1356e8ae840acda787d9bb2b779d11b375ad9a525ffb">TCC_CHANNEL_FUNCTION_CAPTURE</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCC channel operation modes.  <a href="group__asfdoc__sam0__tcc__group.html#gaeaa625722173a7f2d75ac1356e8ae840">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#ga1391584a88af0ec6114c29ca469285b3">tcc_fault_halt_action</a> { <a class="el" href="group__asfdoc__sam0__tcc__group.html#gga1391584a88af0ec6114c29ca469285b3a4e37d085c8dbe7be8a93ea50ee2b5104">TCC_FAULT_HALT_ACTION_DISABLE</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga1391584a88af0ec6114c29ca469285b3ac95bd7272d2fdb799e61cc5c59c415ec">TCC_FAULT_HALT_ACTION_HW_HALT</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga1391584a88af0ec6114c29ca469285b3a49ed4ee870ef6a399883f45e0232f7fb">TCC_FAULT_HALT_ACTION_SW_HALT</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga1391584a88af0ec6114c29ca469285b3a36c7d81023fd3f9b60291edba83239f1">TCC_FAULT_HALT_ACTION_NON_RECOVERABLE</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCC (recoverable) fault Halt action.  <a href="group__asfdoc__sam0__tcc__group.html#ga1391584a88af0ec6114c29ca469285b3">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#ga717a45534e91262d6633f12ff13e6089">tcc_fault_capture_action</a> { <br/>
&#160;&#160;<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga717a45534e91262d6633f12ff13e6089aa10b402bd4d4ba19f89a0d10867bc2f9">TCC_FAULT_CAPTURE_DISABLE</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga717a45534e91262d6633f12ff13e6089a1fbcf718db17a9717ae725acc2127431">TCC_FAULT_CAPTURE_EACH</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga717a45534e91262d6633f12ff13e6089a7ba4b230f6d38522c28fac8fae666211">TCC_FAULT_CAPTURE_MINIMUM</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga717a45534e91262d6633f12ff13e6089a8e7d43d838c58991ea2d09501094ed0a">TCC_FAULT_CAPTURE_MAXIMUM</a>, 
<br/>
&#160;&#160;<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga717a45534e91262d6633f12ff13e6089a5fdfb48df41a86fd830abe0a8aab34ba">TCC_FAULT_CAPTURE_SMALLER</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga717a45534e91262d6633f12ff13e6089adf520e91c4781ef402c3b93e0d94f098">TCC_FAULT_CAPTURE_BIGGER</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga717a45534e91262d6633f12ff13e6089a4841c2b9b65527867ec63dbddb814201">TCC_FAULT_CAPTURE_CHANGE</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCC (recoverable) fault Capture action.  <a href="group__asfdoc__sam0__tcc__group.html#ga717a45534e91262d6633f12ff13e6089">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#gaa2a1f2c8fe209042dd51c1667ed9d0ce">tcc_fault_capture_channel</a> { <a class="el" href="group__asfdoc__sam0__tcc__group.html#ggaa2a1f2c8fe209042dd51c1667ed9d0cea441e0349c9f7d97de4cd79791c3534e1">TCC_FAULT_CAPTURE_CHANNEL_0</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggaa2a1f2c8fe209042dd51c1667ed9d0ceae5498f30d4e119cb333bb46112f0c8e3">TCC_FAULT_CAPTURE_CHANNEL_1</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggaa2a1f2c8fe209042dd51c1667ed9d0ceacc18e785914ed026fa59da4703dbeeeb">TCC_FAULT_CAPTURE_CHANNEL_2</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggaa2a1f2c8fe209042dd51c1667ed9d0cea77a47b6923340d09df54e606ee1b404f">TCC_FAULT_CAPTURE_CHANNEL_3</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Capture Channel triggered by TCC (recoverable) fault.  <a href="group__asfdoc__sam0__tcc__group.html#gaa2a1f2c8fe209042dd51c1667ed9d0ce">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#ga5284d364c10d209e5f8514cf950f1091">tcc_fault_source</a> { <a class="el" href="group__asfdoc__sam0__tcc__group.html#gga5284d364c10d209e5f8514cf950f1091a5c73948a12b2bd2b5992a651435474bc">TCC_FAULT_SOURCE_DISABLE</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga5284d364c10d209e5f8514cf950f1091a7216e4a2f377b9aa3e9574bf512447b6">TCC_FAULT_SOURCE_ENABLE</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga5284d364c10d209e5f8514cf950f1091a93bbdfe094463eca72b800ad118fb035">TCC_FAULT_SOURCE_INVERT</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#gga5284d364c10d209e5f8514cf950f1091a74573ab6554f700ee248e9b92dbc34ca">TCC_FAULT_SOURCE_ALTFAULT</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCC (recoverable) fault Input Source.  <a href="group__asfdoc__sam0__tcc__group.html#ga5284d364c10d209e5f8514cf950f1091">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#gafef8af6ab243449286fef8e55b1b6363">tcc_fault_blanking</a> { <a class="el" href="group__asfdoc__sam0__tcc__group.html#ggafef8af6ab243449286fef8e55b1b6363abc18836dec5fc7d3d790d3b08ef8729c">TCC_FAULT_BLANKING_DISABLE</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggafef8af6ab243449286fef8e55b1b6363acad16d518e77af4446e81d16c13f67f3">TCC_FAULT_BLANKING_RISING_EDGE</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggafef8af6ab243449286fef8e55b1b6363a1df053892368d1874c83b168d023e7ab">TCC_FAULT_BLANKING_FALLING_EDGE</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggafef8af6ab243449286fef8e55b1b6363a59a2c695ad9e24f8e3ea4dfb5e18dd4c">TCC_FAULT_BLANKING_BOTH_EDGE</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCC (recoverable) fault Input Blanking Start Point.  <a href="group__asfdoc__sam0__tcc__group.html#gafef8af6ab243449286fef8e55b1b6363">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#gab8eaffb29665b7f55a822a0aaae4e494">tcc_fault_qualification</a> { <a class="el" href="group__asfdoc__sam0__tcc__group.html#ggab8eaffb29665b7f55a822a0aaae4e494ae03b24cc21739972b3d79f75c23622ab">TCC_FAULT_QUALIFICATION_DISABLE</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggab8eaffb29665b7f55a822a0aaae4e494a29e06986875af6af970573f1a780a456">TCC_FAULT_QUALIFICATION_BY_OUTPUT</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCC (recoverable) fault Input Qualification Action.  <a href="group__asfdoc__sam0__tcc__group.html#gab8eaffb29665b7f55a822a0aaae4e494">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#gabb474178919742afb4aa6c5e2d311c8c">tcc_fault_keep</a> { <a class="el" href="group__asfdoc__sam0__tcc__group.html#ggabb474178919742afb4aa6c5e2d311c8cacfea32367135e975dd7ed631ef66f385">TCC_FAULT_KEEP_DISABLE</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggabb474178919742afb4aa6c5e2d311c8ca1f79015009bf985ae7182241a75bb9b3">TCC_FAULT_KEEP_TILL_END</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCC (recoverable) fault Output Keep Action.  <a href="group__asfdoc__sam0__tcc__group.html#gabb474178919742afb4aa6c5e2d311c8c">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#gaef8e2c6de33a11029ffaf0fc2011f118">tcc_fault_state_output</a> { <a class="el" href="group__asfdoc__sam0__tcc__group.html#ggaef8e2c6de33a11029ffaf0fc2011f118a9ac9783b62d1fae4b066259b93d85282">TCC_FAULT_STATE_OUTPUT_OFF</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggaef8e2c6de33a11029ffaf0fc2011f118aac863b3a350db4e9d4c269bf0a3dc397">TCC_FAULT_STATE_OUTPUT_0</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggaef8e2c6de33a11029ffaf0fc2011f118a4354f291aac34dd8ee1e8a2f125b308b">TCC_FAULT_STATE_OUTPUT_1</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCC Non-recoverable State Outupt.  <a href="group__asfdoc__sam0__tcc__group.html#gaef8e2c6de33a11029ffaf0fc2011f118">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#gab097e6632653be4b5ae56c011423b3a3">tcc_fault_restart</a> { <a class="el" href="group__asfdoc__sam0__tcc__group.html#ggab097e6632653be4b5ae56c011423b3a3af5b6bef00fc0413143e42778a33e1a6f">TCC_FAULT_RESTART_DISABLE</a>, 
<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggab097e6632653be4b5ae56c011423b3a3a419bc4ac915713b649e3c28c750d6941">TCC_FAULT_RESTART_ENABLE</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TCC (recoverable) fault Restart Action.  <a href="group__asfdoc__sam0__tcc__group.html#gab097e6632653be4b5ae56c011423b3a3">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0989bb1ceae5e8be349f09a6d72cb84b"></a><!-- doxytag: member="asfdoc_sam0_tcc_group::_tcc_get_inst_index" ref="ga0989bb1ceae5e8be349f09a6d72cb84b" args="(Tcc *const hw)" -->
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>_tcc_get_inst_index</b> (<a class="el" href="struct_tcc.html">Tcc</a> *const hw)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Module Status Flags</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpdd98d5e8b9a5fd30d323c8eeeab117f4"></a> TCC status flags, returned by tcc_get_status() and cleared by tcc_clear_status(). </p>
</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#ga043dfcc6d7553b6835e442a00935b070">TCC_STATUS_CHANNEL_MATCH_CAPTURE</a>(ch)&#160;&#160;&#160;(1UL &lt;&lt; (ch))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#ga50d80659cbd8ed63a757902b5c11703f">TCC_STATUS_CHANNEL_OUTPUT</a>(ch)&#160;&#160;&#160;(1UL &lt;&lt; ((ch)+8))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#ga3194323a097d8b56b950cfa0fd50ced5">TCC_STATUS_NON_RECOVERABLE_FAULT_OCCUR</a>(x)&#160;&#160;&#160;(1UL &lt;&lt; ((x)+16))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#gac99cebef0c7ab79a190e91ce6eada69c">TCC_STATUS_RECOVERABLE_FAULT_OCCUR</a>(n)&#160;&#160;&#160;(1UL &lt;&lt; ((n)+18))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#ga24d2976610d23257e962e9f58de28390">TCC_STATUS_NON_RECOVERABLE_FAULT_PRESENT</a>(x)&#160;&#160;&#160;(1UL &lt;&lt; ((x)+20))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#ga4c104862376fe400eb02b722827da4b3">TCC_STATUS_RECOVERABLE_FAULT_PRESENT</a>(n)&#160;&#160;&#160;(1UL &lt;&lt; ((n)+22))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#ga0f4626fd0e09291e69d97889385cd751">TCC_STATUS_SYNC_READY</a>&#160;&#160;&#160;(1UL &lt;&lt; 23)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#ga2c10249e8654af00046dd8d636943270">TCC_STATUS_CAPTURE_OVERFLOW</a>&#160;&#160;&#160;(1UL &lt;&lt; 24)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#ga610153459aac614891331b44983008cb">TCC_STATUS_COUNTER_EVENT</a>&#160;&#160;&#160;(1UL &lt;&lt; 25)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#gaf962f3ea13353cbd80b1fb432e44a668">TCC_STATUS_COUNTER_RETRIGGERED</a>&#160;&#160;&#160;(1UL &lt;&lt; 26)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#ga2808c18e7802c7ef3d61f7a7070550c1">TCC_STATUS_COUNT_OVERFLOW</a>&#160;&#160;&#160;(1UL &lt;&lt; 27)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#ga3cca37ff8758f5e0954c87f2deae799c">TCC_STATUS_RAMP_CYCLE_INDEX</a>&#160;&#160;&#160;(1UL &lt;&lt; 28)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tcc__group.html#ga253735ed7d35e1747722b246ea97a46d">TCC_STATUS_STOPPED</a>&#160;&#160;&#160;(1UL &lt;&lt; 29)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Driver Initialization and Configuration</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6062f0f70ac4a4ff6f7deebdb744bc36"></a><!-- doxytag: member="asfdoc_sam0_tcc_group::tcc_get_config_defaults" ref="ga6062f0f70ac4a4ff6f7deebdb744bc36" args="(struct tcc_config *const config, Tcc *const hw)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>tcc_get_config_defaults</b> (struct <a class="el" href="structtcc__config.html">tcc_config</a> *const config, <a class="el" href="struct_tcc.html">Tcc</a> *const hw)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga884ae7434d273c4ef457b31f74779c91"></a><!-- doxytag: member="asfdoc_sam0_tcc_group::tcc_init" ref="ga884ae7434d273c4ef457b31f74779c91" args="(struct tcc_module *const module_inst, Tcc *const hw, const struct tcc_config *const config)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tcc_init</b> (struct <a class="el" href="structtcc__module.html">tcc_module</a> *const module_inst, <a class="el" href="struct_tcc.html">Tcc</a> *const hw, const struct <a class="el" href="structtcc__config.html">tcc_config</a> *const config)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Event Management</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga040f00d183d7ba4841667097f04a13b7"></a><!-- doxytag: member="asfdoc_sam0_tcc_group::tcc_enable_events" ref="ga040f00d183d7ba4841667097f04a13b7" args="(struct tcc_module *const module_inst, struct tcc_events *const events)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tcc_enable_events</b> (struct <a class="el" href="structtcc__module.html">tcc_module</a> *const module_inst, struct <a class="el" href="structtcc__events.html">tcc_events</a> *const events)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga58aab4c93d2143cb59e27ccaf8d500b1"></a><!-- doxytag: member="asfdoc_sam0_tcc_group::tcc_disable_events" ref="ga58aab4c93d2143cb59e27ccaf8d500b1" args="(struct tcc_module *const module_inst, struct tcc_events *const events)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>tcc_disable_events</b> (struct <a class="el" href="structtcc__module.html">tcc_module</a> *const module_inst, struct <a class="el" href="structtcc__events.html">tcc_events</a> *const events)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Get/Set Count Value</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga88170cf16dc1651d98818faf2261e7b9"></a><!-- doxytag: member="asfdoc_sam0_tcc_group::tcc_get_count_value" ref="ga88170cf16dc1651d98818faf2261e7b9" args="(const struct tcc_module *const module_inst)" -->
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>tcc_get_count_value</b> (const struct <a class="el" href="structtcc__module.html">tcc_module</a> *const module_inst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga48bfc0785c7c8c48d1fd7cdd3372926f"></a><!-- doxytag: member="asfdoc_sam0_tcc_group::tcc_set_count_value" ref="ga48bfc0785c7c8c48d1fd7cdd3372926f" args="(const struct tcc_module *const module_inst, const uint32_t count)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tcc_set_count_value</b> (const struct <a class="el" href="structtcc__module.html">tcc_module</a> *const module_inst, const uint32_t count)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Get/Set Compare/Capture Register</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7935177f740384d2750ebd26e567d4b3"></a><!-- doxytag: member="asfdoc_sam0_tcc_group::tcc_get_capture_value" ref="ga7935177f740384d2750ebd26e567d4b3" args="(const struct tcc_module *const module_inst, const enum tcc_match_capture_channel channel_index)" -->
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>tcc_get_capture_value</b> (const struct <a class="el" href="structtcc__module.html">tcc_module</a> *const module_inst, const enum <a class="el" href="group__asfdoc__sam0__tcc__group.html#gaf0ea531eacd92224d87ebdaf63db6c86">tcc_match_capture_channel</a> channel_index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga148b949ab1837b9a0d959a85db30c895"></a><!-- doxytag: member="asfdoc_sam0_tcc_group::tcc_set_compare_value" ref="ga148b949ab1837b9a0d959a85db30c895" args="(const struct tcc_module *const module_inst, const enum tcc_match_capture_channel channel_index, const uint32_t compare)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tcc_set_compare_value</b> (const struct <a class="el" href="structtcc__module.html">tcc_module</a> *const module_inst, const enum <a class="el" href="group__asfdoc__sam0__tcc__group.html#gaf0ea531eacd92224d87ebdaf63db6c86">tcc_match_capture_channel</a> channel_index, const uint32_t compare)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Set Top Value</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga68e2b9015b489adcde4a4fbf95fa532a"></a><!-- doxytag: member="asfdoc_sam0_tcc_group::tcc_set_top_value" ref="ga68e2b9015b489adcde4a4fbf95fa532a" args="(const struct tcc_module *const module_inst, const uint32_t top_value)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tcc_set_top_value</b> (const struct <a class="el" href="structtcc__module.html">tcc_module</a> *const module_inst, const uint32_t top_value)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Set Output Pattern</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0c25e69a486f9408b655b1ba77656f65"></a><!-- doxytag: member="asfdoc_sam0_tcc_group::tcc_set_pattern" ref="ga0c25e69a486f9408b655b1ba77656f65" args="(const struct tcc_module *const module_inst, const uint32_t line_index, const enum tcc_output_pattern pattern)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tcc_set_pattern</b> (const struct <a class="el" href="structtcc__module.html">tcc_module</a> *const module_inst, const uint32_t line_index, const enum <a class="el" href="group__asfdoc__sam0__tcc__group.html#gae308e9eeb120db42f773f680118fe340">tcc_output_pattern</a> pattern)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Status Management</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga90c6091d5e5770eba29e2dff5c11b9ad"></a><!-- doxytag: member="asfdoc_sam0_tcc_group::tcc_get_status" ref="ga90c6091d5e5770eba29e2dff5c11b9ad" args="(struct tcc_module *const module_inst)" -->
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>tcc_get_status</b> (struct <a class="el" href="structtcc__module.html">tcc_module</a> *const module_inst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9001f503ac628a6fc781043cf774a69c"></a><!-- doxytag: member="asfdoc_sam0_tcc_group::tcc_clear_status" ref="ga9001f503ac628a6fc781043cf774a69c" args="(struct tcc_module *const module_inst, const uint32_t status_flags)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>tcc_clear_status</b> (struct <a class="el" href="structtcc__module.html">tcc_module</a> *const module_inst, const uint32_t status_flags)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Double Buffering Management</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaa69c7c91b8e147c07667ddc6c85b205"></a><!-- doxytag: member="asfdoc_sam0_tcc_group::tcc_set_double_buffer_top_values" ref="gaaa69c7c91b8e147c07667ddc6c85b205" args="(const struct tcc_module *const module_inst, const uint32_t top_value, const uint32_t top_buffer_value)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tcc_set_double_buffer_top_values</b> (const struct <a class="el" href="structtcc__module.html">tcc_module</a> *const module_inst, const uint32_t top_value, const uint32_t top_buffer_value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9db66c43221dfe62f1a3e91bda2be3ee"></a><!-- doxytag: member="asfdoc_sam0_tcc_group::tcc_enable_circular_buffer_compare" ref="ga9db66c43221dfe62f1a3e91bda2be3ee" args="(struct tcc_module *const module_inst, enum tcc_match_capture_channel channel_index)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tcc_enable_circular_buffer_compare</b> (struct <a class="el" href="structtcc__module.html">tcc_module</a> *const module_inst, enum <a class="el" href="group__asfdoc__sam0__tcc__group.html#gaf0ea531eacd92224d87ebdaf63db6c86">tcc_match_capture_channel</a> channel_index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5ce23486a6282ecb0a46a8b05eb517a9"></a><!-- doxytag: member="asfdoc_sam0_tcc_group::tcc_disable_circular_buffer_compare" ref="ga5ce23486a6282ecb0a46a8b05eb517a9" args="(struct tcc_module *const module_inst, enum tcc_match_capture_channel channel_index)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tcc_disable_circular_buffer_compare</b> (struct <a class="el" href="structtcc__module.html">tcc_module</a> *const module_inst, enum <a class="el" href="group__asfdoc__sam0__tcc__group.html#gaf0ea531eacd92224d87ebdaf63db6c86">tcc_match_capture_channel</a> channel_index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga87f2a983a22e8a60e75e7dfc3a04c2b0"></a><!-- doxytag: member="asfdoc_sam0_tcc_group::tcc_set_double_buffer_compare_values" ref="ga87f2a983a22e8a60e75e7dfc3a04c2b0" args="(struct tcc_module *const module_inst, enum tcc_match_capture_channel channel_index, const uint32_t compare, const uint32_t compare_buffer)" -->
enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tcc_set_double_buffer_compare_values</b> (struct <a class="el" href="structtcc__module.html">tcc_module</a> *const module_inst, enum <a class="el" href="group__asfdoc__sam0__tcc__group.html#gaf0ea531eacd92224d87ebdaf63db6c86">tcc_match_capture_channel</a> channel_index, const uint32_t compare, const uint32_t compare_buffer)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>This driver for Atmel&reg; | SMART SAM devices provides an interface for the configuration and management of the TCC module within the device, for waveform generation and timing operations. It also provides extended options for control applications.</p>
<p>The following driver API modes are covered by this manual:</p>
<ul>
<li>Polled APIs</li>
</ul>
<p>The following peripherals are used by this module:</p>
<ul>
<li>TCC (Timer/Counter for Control Applications)</li>
</ul>
<p>The following devices can use this module:</p>
<ul>
<li>Atmel | SMART SAM D21</li>
<li>Atmel | SMART SAM R21</li>
<li>Atmel | SMART SAM D10/D11</li>
<li>Atmel | SMART SAM L21</li>
<li>Atmel | SMART SAM DAx</li>
<li>Atmel | SMART SAM C20/C21</li>
</ul>
<p>The outline of this documentation is as follows:</p>
<ul>
<li><a class="el" href="group__asfdoc__sam0__tcc__group.html#asfdoc_sam0_tcc_prerequisites">Prerequisites</a></li>
<li><a class="el" href="group__asfdoc__sam0__tcc__group.html#asfdoc_sam0_tcc_module_overview">Module Overview</a></li>
<li><a class="el" href="group__asfdoc__sam0__tcc__group.html#asfdoc_sam0_tcc_special_considerations">Special Considerations</a></li>
<li><a class="el" href="group__asfdoc__sam0__tcc__group.html#asfdoc_sam0_tcc_extra_info">Extra Information</a></li>
<li><a class="el" href="group__asfdoc__sam0__tcc__group.html#asfdoc_sam0_tcc_examples">Examples</a></li>
<li><a class="el" href="group__asfdoc__sam0__tcc__group.html#asfdoc_sam0_tcc_api_overview">API Overview</a></li>
</ul>
<h2><a class="anchor" id="asfdoc_sam0_tcc_prerequisites"></a>
Prerequisites</h2>
<p>There are no prerequisites for this module.</p>
<h2><a class="anchor" id="asfdoc_sam0_tcc_module_overview"></a>
Module Overview</h2>
<p>The Timer/Counter for Control Applications (TCC) module provides a set of timing and counting related functionality, such as the generation of periodic waveforms, the capturing of a periodic waveform's frequency/duty cycle, software timekeeping for periodic operations, waveform extension control, fault detection etc.</p>
<p>The counter size of the TCC modules can be 16- or 24-bit depending on the TCC instance. Refer <a class="el" href="group__asfdoc__sam0__tcc__group.html#asfdoc_sam0_tcc_special_considerations_tcc_d21">SAM TCC Feature List</a> and <a class="el" href="group__asfdoc__sam0__tcc__group.html#asfdoc_sam0_tcc_special_considerations_tcc_d11">SAM D10/D11 TCC Feature List</a> for details on TCC instances.</p>
<p>The TCC module for the SAM includes the following functions:</p>
<ul>
<li>Generation of PWM signals</li>
<li>Generation of timestamps for events</li>
<li>General time counting</li>
<li>Waveform period capture</li>
<li>Waveform frequency capture</li>
<li>Additional control for generated waveform outputs</li>
<li>Fault protection for waveform generation</li>
</ul>
<p><a class="el" href="group__asfdoc__sam0__tcc__group.html#asfdoc_sam0_tcc_block_diagram">The diagram below</a> shows the overview of the TCC Module.</p>
<p><a class="anchor" id="asfdoc_sam0_tcc_block_diagram"></a> </p>
<div class="image">
<img src="overview.svg" alt="overview.svg"/>
<div class="caption">
Overview of the TCC Module</div></div>
 <h3><a class="anchor" id="asfdoc_sam0_tcc_module_overview_parts"></a>
Functional Description</h3>
<p>The TCC module consists of following sections:</p>
<ul>
<li>Base Counter</li>
<li>Compare/Capture channels, with waveform generation</li>
<li>Waveform extension control and fault detection</li>
<li>Interface to the event system, DMAC, and the interrupt system</li>
</ul>
<p>The base counter can be configured to either count a prescaled generic clock or events from the event system.(TCEx, with event action configured to counting). The counter value can be used by compare/capture channels which can be set up either in compare mode or capture mode.</p>
<p>In capture mode, the counter value is stored when a configurable event occurs. This mode can be used to generate timestamps used in event capture, or it can be used for the measurement of a periodic input signal's frequency/duty cycle.</p>
<p>In compare mode, the counter value is compared against one or more of the configured channels' compare values. When the counter value coincides with a compare value an action can be taken automatically by the module, such as generating an output event or toggling a pin when used for frequency or PWM signal generation.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The connection of events between modules requires the use of the SAM Event System Driver (EVENTS) to route output event of one module to the the input event of another. For more information on event routing, refer to the event driver documentation.</dd></dl>
<p>In compare mode, when output signal is generated, extended waveform controls are available, to arrange the compare outputs into specific formats. The Output matrix can change the channel output routing. Pattern generation unit can overwrite the output signal line to specific state. The Fault protection feature of the TCC supports recoverable and non-recoverable faults.</p>
<h3><a class="anchor" id="asfdoc_sam0_tcc_module_overview_tc"></a>
Base Timer/Counter</h3>
<h4><a class="anchor" id="asfdoc_sam0_tcc_module_overview_tc_size"></a>
Timer/Counter Size</h4>
<p>Each TCC has a counter size of either 16- or 24-bits. The size of the counter determines the maximum value it can count to before an overflow occurs. <a class="el" href="group__asfdoc__sam0__tcc__group.html#asfdoc_sam0_tcc_count_size_vs_top">The table below</a> shows the maximum values for each of the possible counter sizes.</p>
<p><a class="anchor" id="asfdoc_sam0_tcc_count_size_vs_top"></a> </p>
<table class="doxtable">
<caption align="bottom">Timer Counter Sizes and Their Maximum Count Values</caption>
<tr>
<th>Counter size </th><th>Max. (hexadecimal) </th><th>Max. (decimal)  </th></tr>
<tr>
<td>16-bit </td><td>0xFFFF </td><td>65,535  </td></tr>
<tr>
<td>24-bit </td><td>0xFFFFFF </td><td>16,777,215  </td></tr>
</table>
<p>The period/top value of the counter can be set, to define counting period. This will allow the counter to overflow when the counter value reaches the period/top value.</p>
<h4><a class="anchor" id="asfdoc_sam0_tcc_module_overview_tc_clk"></a>
Timer/Counter Clock and Prescaler</h4>
<p>TCC is clocked asynchronously to the system clock by a GCLK (Generic Clock) channel. The GCLK channel can be connected to any of the GCLK generators. The GCLK generators are configured to use one of the available clock sources in the system such as internal oscillator, external crystals, etc. - see the <a class="el" href="group__asfdoc__sam0__system__clock__group.html">Generic Clock driver</a> for more information.</p>
<p>Each TCC module in the SAM has its own individual clock prescaler, which can be used to divide the input clock frequency used by the counter. This prescaler only scales the clock used to provide clock pulses for the counter to count, and does not affect the digital register interface portion of the module, thus the timer registers will synchronized to the raw GCLK frequency input to the module.</p>
<p>As a result of this, when selecting a GCLK frequency and timer prescaler value the user application should consider both the timer resolution required and the synchronization frequency, to avoid lengthy synchronization times of the module if a very slow GCLK frequency is fed into the TCC module. It is preferable to use a higher module GCLK frequency as the input to the timer and prescale this down as much as possible to obtain a suitable counter frequency in latency-sensitive applications.</p>
<h4><a class="anchor" id="asfdoc_sam0_tcc_module_overview_tc_ctrl"></a>
Timer/Counter Control Inputs (Events)</h4>
<p>The TCC can take several actions on the occurrence of an input event. The event actions are listed in <a class="el" href="group__asfdoc__sam0__tcc__group.html#asfdoc_sam0_tcc_module_event_act">events action settings</a>.</p>
<p><a class="anchor" id="asfdoc_sam0_tcc_module_event_act"></a> </p>
<table class="doxtable">
<caption align="bottom">TCC Module Event Actions</caption>
<tr>
<th>Event action </th><th>Description </th><th>Applied event  </th></tr>
<tr>
<td>TCC_EVENT_ACTION_OFF </td><td>No action on the event input </td><td>All  </td></tr>
<tr>
<td>TCC_EVENT_ACTION_RETRIGGER </td><td>Re-trigger Counter on event </td><td>All  </td></tr>
<tr>
<td>TCC_EVENT_ACTION_NON_RECOVERABLE_FAULT </td><td>Generate Non-Recoverable Fault on event </td><td>All  </td></tr>
<tr>
<td>TCC_EVENT_ACTION_START </td><td>Counter start on event </td><td>EV0  </td></tr>
<tr>
<td>TCC_EVENT_ACTION_DIR_CONTROL </td><td>Counter direction control </td><td>EV0  </td></tr>
<tr>
<td>TCC_EVENT_ACTION_DECREMENT </td><td>Counter decrement on event </td><td>EV0  </td></tr>
<tr>
<td>TCC_EVENT_ACTION_PERIOD_PULSE_WIDTH_CAPTURE </td><td>Capture pulse period and pulse width </td><td>EV0  </td></tr>
<tr>
<td>TCC_EVENT_ACTION_PULSE_WIDTH_PERIOD_CAPTURE </td><td>Capture pulse width and pulse period </td><td>EV0  </td></tr>
<tr>
<td>TCC_EVENT_ACTION_STOP </td><td>Counter stop on event </td><td>EV1  </td></tr>
<tr>
<td>TCC_EVENT_ACTION_COUNT_EVENT </td><td>Counter count on event </td><td>EV1  </td></tr>
<tr>
<td>TCC_EVENT_ACTION_INCREMENT </td><td>Counter increment on event </td><td>EV1  </td></tr>
<tr>
<td>TCC_EVENT_ACTION_COUNT_DURING_ACTIVE </td><td>Counter count during active state of asynchronous event </td><td>EV1  </td></tr>
</table>
<h4><a class="anchor" id="asfdoc_sam0_tcc_module_overview_tc_reload"></a>
Timer/Counter Reloading</h4>
<p>The TCC also has a configurable reload action, used when a re-trigger event occurs. Examples of a re-trigger event could be the counter reaching the maximum value when counting up, or when an event from the event system makes the counter to re-trigger. The reload action determines if the prescaler should be reset, and on which clock. The counter will always be reloaded with the value it is set to start counting. The user can choose between three different reload actions, described in <a class="el" href="group__asfdoc__sam0__tcc__group.html#asfdoc_sam0_tcc_module_reload_act">the table below</a>.</p>
<p><a class="anchor" id="asfdoc_sam0_tcc_module_reload_act"></a> </p>
<table class="doxtable">
<caption align="bottom">TCC Module Reload Actions</caption>
<tr>
<th>Reload action </th><th>Description  </th></tr>
<tr>
<td>TCC_RELOAD_ACTION_GCLK </td><td>Reload TCC counter value on next GCLK cycle. Leave prescaler as-is.  </td></tr>
<tr>
<td>TCC_RELOAD_ACTION_PRESC </td><td>Reloads TCC counter value on next prescaler clock. Leave prescaler as-is.  </td></tr>
<tr>
<td>TCC_RELOAD_ACTION_RESYNC </td><td>Reload TCC counter value on next GCLK cycle. Clear prescaler to zero.  </td></tr>
</table>
<p>The reload action to use will depend on the specific application being implemented. One example is when an external trigger for a reload occurs; if the TCC uses the prescaler, the counter in the prescaler should not have a value between zero and the division factor. The counter in the TCC module and the counter in the prescaler should both start at zero. If the counter is set to re-trigger when it reaches the maximum value, this is not the right option to use. In such a case it would be better if the prescaler is left unaltered when the re-trigger happens, letting the counter reset on the next GCLK cycle.</p>
<h4><a class="anchor" id="asfdoc_sam0_tcc_module_overview_tc_oneshot"></a>
One-shot Mode</h4>
<p>The TCC module can be configured in one-shot mode. When configured in this manner, starting the timer will cause it to count until the next overflow or underflow condition before automatically halting, waiting to be manually triggered by the user application software or an event from the event system.</p>
<h3><a class="anchor" id="asfdoc_sam0_tcc_module_overview_capt"></a>
Capture Operations</h3>
<p>In capture operations, any event from the event system or a pin change can trigger a capture of the counter value. This captured counter value can be used as timestamps for the events, or it can be used in frequency and pulse width capture.</p>
<h4><a class="anchor" id="asfdoc_sam0_tcc_module_overview_capt_ev"></a>
Capture Operations - Event</h4>
<p>Event capture is a simple use of the capture functionality, designed to create timestamps for specific events. When the input event appears, the current counter value is copied into the corresponding compare/capture register, which can then be read by the user application.</p>
<p>Note that when performing any capture operation, there is a risk that the counter reaches its top value (MAX) when counting up, or the bottom value (zero) when counting down, before the capture event occurs. This can distort the result, making event timestamps to appear shorter than they really are. In this case, the user application should check for timer overflow when reading a capture result in order to detect this situation and perform an appropriate adjustment.</p>
<p>Before checking for a new capture, <a class="el" href="group__asfdoc__sam0__tcc__group.html#ga2808c18e7802c7ef3d61f7a7070550c1">TCC_STATUS_COUNT_OVERFLOW</a> should be checked. The response to an overflow error is left to the user application, however it may be necessary to clear both the overflow flag and the capture flag upon each capture reading.</p>
<h4><a class="anchor" id="asfdoc_sam0_tcc_module_overview_capt_pulse"></a>
Capture Operations - Pulse Width</h4>
<p>Pulse Width Capture mode makes it possible to measure the pulse width and period of PWM signals. This mode uses two capture channels of the counter. There are two modes for pulse width capture; Pulse Width Period (PWP) and Period Pulse Width (PPW). In PWP mode, capture channel 0 is used for storing the pulse width and capture channel 1 stores the observed period. While in PPW mode, the roles of the two capture channels are reversed.</p>
<p>As in the above example it is necessary to poll on interrupt flags to see if a new capture has happened and check that a capture overflow error has not occurred.</p>
<p>Refer to <a class="el" href="group__asfdoc__sam0__tcc__group.html#asfdoc_sam0_tcc_module_overview_tc_ctrl">Timer/Counter Control Inputs (Events)</a> to set up the input event to perform pulse width capture.</p>
<h3><a class="anchor" id="asfdoc_sam0_tcc_module_overview_mc"></a>
Compare Match Operation</h3>
<p>In compare match operation, Compare/Capture registers are compared with the counter value. When the timer's count value matches the value of a compare channel, a user defined action can be taken.</p>
<h4><a class="anchor" id="asfdoc_sam0_tcc_module_overview_mc_timer"></a>
Basic Timer</h4>
<p>A Basic Timer is a simple application where compare match operation is used to determine when a specific period has elapsed. In Basic Timer operations, one or more values in the module's Compare/Capture registers are used to specify the time (in terms of the number of prescaled GCLK cycles, or input events) at which an action should be taken by the microcontroller. This can be an Interrupt Service Routine (ISR), event generation via the event system, or a software flag that is polled from the user application.</p>
<h4><a class="anchor" id="asfdoc_sam0_tcc_module_overview_mc_wave"></a>
Waveform Generation</h4>
<p>Waveform generation enables the TCC module to generate square waves, or if combined with an external passive low-pass filter, analog waveforms.</p>
<h4><a class="anchor" id="asfdoc_sam0_tcc_module_overview_mc_wave_pwm"></a>
Waveform Generation - PWM</h4>
<p>Pulse width modulation is a form of waveform generation and a signalling technique that can be useful in many applications. When PWM mode is used, a digital pulse train with a configurable frequency and duty cycle can be generated by the TCC module and output to a GPIO pin of the device.</p>
<p>Often PWM is used to communicate a control or information parameter to an external circuit or component. Differing impedances of the source generator and sink receiver circuits is less of an issue when using PWM compared to using an analog voltage value, as noise will not generally affect the signal's integrity to a meaningful extent.</p>
<p><a class="el" href="group__asfdoc__sam0__tcc__group.html#asfdoc_sam0_tcc_module_pwm_single_diag">The figure below</a> illustrates operations and different states of the counter and its output when using the timer in Normal PWM mode (Single Slope). As can be seen, the TOP/PERIOD value is unchanged and is set to MAX. The compare match value is changed at several points to illustrate the resulting waveform output changes. The PWM output is set to normal (i.e. non-inverted) output mode.</p>
<p><a class="anchor" id="asfdoc_sam0_tcc_module_pwm_single_diag"></a> </p>
<div class="image">
<img src="pwm_single_ex.svg" alt="pwm_single_ex.svg"/>
<div class="caption">
Example Of PWM In Single-Slope Mode, and Different Counter Operations</div></div>
<p> Several PWM modes are supported by the TCC module, refer to datasheet for the details on PWM waveform generation.</p>
<h4><a class="anchor" id="asfdoc_sam0_tcc_module_overview_mc_wave_freq"></a>
Waveform Generation - Frequency</h4>
<p>Normal Frequency Generation is in many ways identical to PWM generation. However, only in Frequency Generation, a toggle occurs on the output when a match on a compare channels occurs.</p>
<p>When the Match Frequency Generation is used, the timer value is reset on match condition, resulting in a variable frequency square wave with a fixed 50% duty cycle.</p>
<h3><a class="anchor" id="asfdoc_sam0_tcc_module_overview_ext"></a>
Waveform Extended Controls</h3>
<h4><a class="anchor" id="asfdoc_sam0_tcc_module_overview_ext_pat"></a>
Pattern Generation</h4>
<p>Pattern insertion allows the TCC module to change the actual pin output level without modifying the compare/match settings.</p>
<p><a class="anchor" id="asfdoc_sam0_tcc_module_pattern_gen"></a> </p>
<table class="doxtable">
<caption align="bottom">TCC Module Output Pattern Generation</caption>
<tr>
<th>Pattern </th><th>Description  </th></tr>
<tr>
<td>TCC_OUTPUT_PATTERN_DISABLE </td><td>Pattern disabled, generate output as is  </td></tr>
<tr>
<td>TCC_OUTPUT_PATTERN_0 </td><td>Generate pattern 0 on output (keep the output LOW)  </td></tr>
<tr>
<td>TCC_OUTPUT_PATTERN_1 </td><td>Generate pattern 1 on output (keep the output HIGH)  </td></tr>
</table>
<h4><a class="anchor" id="asfdoc_sam0_tcc_module_overview_ext_r_fault"></a>
Recoverable Faults</h4>
<p>The recoverable faults can trigger one or several of following fault actions:</p>
<ol type="1">
<li>*Halt* action: The recoverable faults can halt the TCC timer/counter, so that the final output wave is kept at a defined state. When the fault state is removed it is possible to recover the counter and waveform generation. The halt action is defined as: <a class="anchor" id="asfdoc_sam0_tcc_module_fault_halt_action"></a> <table class="doxtable">
<caption align="bottom">TCC Module Recoverable Fault Halt Actions</caption>
<tr>
<th>Action </th><th>Description  </th></tr>
<tr>
<td>TCC_FAULT_HALT_ACTION_DISABLE </td><td>Halt action is disabled  </td></tr>
<tr>
<td>TCC_FAULT_HALT_ACTION_HW_HALT </td><td>The timer/counter is halted as long as the corresponding fault is present  </td></tr>
<tr>
<td>TCC_FAULT_HALT_ACTION_SW_HALT </td><td>The timer/counter is halted until the corresponding fault is removed and fault state cleared by software  </td></tr>
<tr>
<td>TCC_FAULT_HALT_ACTION_NON_RECOVERABLE </td><td>Force all the TCC output pins to a pre-defined level, as what Non-Recoverable Fault do  </td></tr>
</table>
</li>
<li>*Restart* action: When enabled, the recoverable faults can restart the TCC timer/counter.</li>
<li>*Keep* action: When enabled, the recoverable faults can keep the corresponding channel output to zero when the fault condition is present.</li>
<li>*Capture* action: When the recoverable fault occurs, the capture action can time stamps the corresponding fault. The following capture mode is supported: <a class="anchor" id="asfdoc_sam0_tcc_module_fault_capt_action"></a> <table class="doxtable">
<caption align="bottom">TCC Module Recoverable Fault Capture Actions</caption>
<tr>
<th>Action </th><th>Description  </th></tr>
<tr>
<td>TCC_FAULT_CAPTURE_DISABLE </td><td>Capture action is disabled  </td></tr>
<tr>
<td>TCC_FAULT_CAPTURE_EACH </td><td>Equivalent to standard capture operation, on each fault occurrence the time stamp is captured  </td></tr>
<tr>
<td>TCC_FAULT_CAPTURE_MINIMUM </td><td>Get the minimum time stamped value in all time stamps  </td></tr>
<tr>
<td>TCC_FAULT_CAPTURE_MAXIMUM </td><td>Get the maximum time stamped value in all time stamps  </td></tr>
<tr>
<td>TCC_FAULT_CAPTURE_SMALLER </td><td>Time stamp the fault input if the value is smaller than last one  </td></tr>
<tr>
<td>TCC_FAULT_CAPTURE_BIGGER </td><td>Time stamp the fault input if the value is bigger than last one  </td></tr>
<tr>
<td>TCC_FAULT_CAPTURE_CHANGE </td><td>Time stamp the fault input if the time stamps changes its increment direction  </td></tr>
</table>
</li>
</ol>
<p>In TCC module, only the first two compare channels (CC0 and CC1) can work with recoverable fault inputs. The corresponding event inputs (TCCx MC0 and TCCx MC1) are then used as fault inputs respectively. The faults are called Fault A and Fault B.</p>
<p>The recoverable fault can be filtered or effected by corresponding channel output. On fault condition there are many other settings that can be chosen. Refer to data sheet for more details about the recoverable fault operations.</p>
<h4><a class="anchor" id="asfdoc_sam0_tcc_module_overview_ext_n_fault"></a>
Non-Recoverable Faults</h4>
<p>The non-recoverable faults force all the TCC output pins to a pre-defined level (can be forced to 0 or 1). The input control signal of non-recoverable fault is from timer/counter event (TCCx EV0 and TCCx EV1). To enable non-recoverable fault, corresponding TCEx event action must be set to non-recoverable fault action (<a class="el" href="group__asfdoc__sam0__tcc__group.html#ggaaa34ddec58a743f0b079ed882bd7fa02a820646e92211693414a7a4e740510bb4">TCC_EVENT_ACTION_NON_RECOVERABLE_FAULT</a>). Refer to <a class="el" href="group__asfdoc__sam0__tcc__group.html#asfdoc_sam0_tcc_module_overview_tc_ctrl">Timer/Counter Control Inputs (Events)</a> to see the available event input action.</p>
<h3><a class="anchor" id="asfdoc_sam0_tcc_module_overview_buffering"></a>
Double and Circular Buffering</h3>
<p>The pattern, period and the compare channels registers are double buffered. For these options there are effective registers (PATT, PER, and CCx) and buffer registers (PATTB, PERB, and CCx). When writing to the buffer registers, the values are buffered and will be committed to effective registers on UPDATE condition.</p>
<p>Usually the buffered value is cleared after it's committed, but there is also option to circular the register buffers. The period (PER) and four lowest compare channels register (CCx, x is 0 ~ 3) support this function. When circular buffer is used, on UPDATE the previous period or compare values are copied back into the corresponding period buffer and compare buffers. This way, the register value and its buffer register value is actually switched on UPDATE condition, and will be switched back on next UPDATE condition.</p>
<p>For input capture, the buffer register (CCBx) and the corresponding capture channel register (CCx) act like a FIFO. When regular register (CCx) is empty or read, any content in the buffer register is passed to regular one.</p>
<p>In TCC module driver, when the double buffering write is enabled, any write through tcc_set_top_value(), tcc_set_compare_value(), and tcc_set_pattern() will be done to the corresponding buffer register. Then the value in the buffer register will be transferred to the regular register on the next UPDATE condition or by a force UPDATE using tcc_force_double_buffer_update().</p>
<h3><a class="anchor" id="asfdoc_sam0_tcc_module_overview_sleep"></a>
Sleep Mode</h3>
<p>TCC modules can be configured to operate in any sleep mode, with its "run
 in standby" function enabled. It can wake up the device using interrupts or perform internal actions with the help of the Event System.</p>
<h2><a class="anchor" id="asfdoc_sam0_tcc_special_considerations"></a>
Special Considerations</h2>
<h3><a class="anchor" id="asfdoc_sam0_tcc_special_considerations_specific_features"></a>
Driver Feature Macro Definition</h3>
<p><a class="el" href="group__asfdoc__sam0__tcc__group.html#asfdoc_sam0_tcc_feature_table">The table below</a> shows some specific features of the TCC Module.</p>
<p><a class="anchor" id="asfdoc_sam0_tcc_feature_table"></a> </p>
<table class="doxtable">
<caption align="bottom">TCC Module Specific Features</caption>
<tr>
<th>Driver Feature Macro </th><th>Supported devices  </th></tr>
<tr>
<td>FEATURE_TCC_GENERATE_DMA_TRIGGER </td><td>SAML21  </td></tr>
</table>
<dl class="note"><dt><b>Note:</b></dt><dd>The specific features are only available in the driver when the selected device supports those features.</dd></dl>
<h3><a class="anchor" id="asfdoc_sam0_tcc_special_considerations_tcc_feature"></a>
Module Features</h3>
<p>The features of TCC, such as timer/counter size, number of compare capture channels, and number of outputs, are dependent on the TCC module instance being used.</p>
<h4><a class="anchor" id="asfdoc_sam0_tcc_special_considerations_tcc_d21"></a>
SAM TCC Feature List</h4>
<p>For SAM D21/R21/L21/DAx/C21, the TCC features are: <a class="anchor" id="asfdoc_sam0_tcc_features_d21"></a> </p>
<table class="doxtable">
<caption align="bottom">TCC module features for SAM D21/R21/L21/DAx/C21</caption>
<tr>
<th>TCC# </th><th>Match/Capture channels </th><th>Wave outputs </th><th>Counter size [bits] </th><th>Fault </th><th>Dithering </th><th>Output matrix </th><th>Dead-Time insertion </th><th>SWAP </th><th>Pattern  </th></tr>
<tr>
<td>0 </td><td>4 </td><td>8 </td><td>24 </td><td>Y </td><td>Y </td><td>Y </td><td>Y </td><td>Y </td><td>Y  </td></tr>
<tr>
<td>1 </td><td>2 </td><td>4 </td><td>24 </td><td>Y </td><td>Y </td><td></td><td></td><td></td><td>Y  </td></tr>
<tr>
<td>2 </td><td>2 </td><td>2 </td><td>16 </td><td>Y </td><td></td><td></td><td></td><td></td><td></td></tr>
</table>
<h4><a class="anchor" id="asfdoc_sam0_tcc_special_considerations_tcc_d11"></a>
SAM D10/D11 TCC Feature List</h4>
<p>For SAM D10/D11, the TCC features are: <a class="anchor" id="asfdoc_sam0_tcc_features_d11"></a> </p>
<table class="doxtable">
<caption align="bottom">TCC Module Features For SAM D10/D11</caption>
<tr>
<th>TCC# </th><th>Match/Capture channels </th><th>Wave outputs </th><th>Counter size [bits] </th><th>Fault </th><th>Dithering </th><th>Output matrix </th><th>Dead-Time insertion </th><th>SWAP </th><th>Pattern  </th></tr>
<tr>
<td>0 </td><td>4 </td><td>8 </td><td>24 </td><td>Y </td><td>Y </td><td>Y </td><td>Y </td><td>Y </td><td>Y  </td></tr>
</table>
<h3><a class="anchor" id="asfdoc_sam0_tcc_special_considerations_tcc_pin"></a>
Channels vs. Pin outs</h3>
<p>As the TCC module may have more waveform output pins than the number of compare/capture channels, the free pins (with number higher than number of channels) will reuse the waveform generated by channels subsequently. E.g., if the number of channels is four and the number of wave output pins is eight, channel 0 output will be available on out pin 0 and 4, channel 1 output on wave out pin 1 and 5, and so on.</p>
<h2><a class="anchor" id="asfdoc_sam0_tcc_extra_info"></a>
Extra Information</h2>
<p>For extra information, see <a class="el" href="asfdoc_sam0_tcc_extra.html">Extra Information for TCC Driver</a>. This includes:</p>
<ul>
<li><a class="el" href="asfdoc_sam0_tcc_extra.html#asfdoc_sam0_tcc_extra_acronyms">Acronyms</a></li>
<li><a class="el" href="asfdoc_sam0_tcc_extra.html#asfdoc_sam0_tcc_extra_dependencies">Dependencies</a></li>
<li><a class="el" href="asfdoc_sam0_tcc_extra.html#asfdoc_sam0_tcc_extra_errata">Errata</a></li>
<li><a class="el" href="asfdoc_sam0_tcc_extra.html#asfdoc_sam0_tcc_extra_history">Module History</a></li>
</ul>
<h2><a class="anchor" id="asfdoc_sam0_tcc_examples"></a>
Examples</h2>
<p>For a list of examples related to this driver, see <a class="el" href="asfdoc_sam0_tcc_exqsg.html">Examples for TCC Driver</a>.</p>
<h2><a class="anchor" id="asfdoc_sam0_tcc_api_overview"></a>
API Overview</h2>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga2fd9e1a57cd1951880c3d5c844463e62"></a><!-- doxytag: member="tcc.h::_TCC_ENUM" ref="ga2fd9e1a57cd1951880c3d5c844463e62" args="(n, type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__tcc__group.html#ga2fd9e1a57cd1951880c3d5c844463e62">_TCC_ENUM</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;TCC_##type##_##n,</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Define port features set according to different device family. </p>

</div>
</div>
<a class="anchor" id="ga06877478c8a906a198f6deae11158bfb"></a><!-- doxytag: member="tcc.h::TCC_NUM_CHANNELS" ref="ga06877478c8a906a198f6deae11158bfb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__tcc__group.html#ga06877478c8a906a198f6deae11158bfb">TCC_NUM_CHANNELS</a>&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Maximum number of channels supported by the driver (Channel index from 0 to <code>TCC_NUM_CHANNELS</code> - 1). </p>

</div>
</div>
<a class="anchor" id="ga1272407779618185ec6492c78db1c493"></a><!-- doxytag: member="tcc.h::TCC_NUM_FAULTS" ref="ga1272407779618185ec6492c78db1c493" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__tcc__group.html#ga1272407779618185ec6492c78db1c493">TCC_NUM_FAULTS</a>&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Maximum number of (recoverable) faults supported by the driver. </p>

</div>
</div>
<a class="anchor" id="ga7b57a63497d3b7c055b3f9abc876b719"></a><!-- doxytag: member="tcc.h::TCC_NUM_WAVE_OUTPUTS" ref="ga7b57a63497d3b7c055b3f9abc876b719" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__tcc__group.html#ga7b57a63497d3b7c055b3f9abc876b719">TCC_NUM_WAVE_OUTPUTS</a>&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Maximum number of wave outputs lines supported by the driver (Output line index from 0 to <code>TCC_NUM_WAVE_OUTPUTS</code> - 1). </p>

</div>
</div>
<a class="anchor" id="ga2c10249e8654af00046dd8d636943270"></a><!-- doxytag: member="tcc.h::TCC_STATUS_CAPTURE_OVERFLOW" ref="ga2c10249e8654af00046dd8d636943270" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__tcc__group.html#ga2c10249e8654af00046dd8d636943270">TCC_STATUS_CAPTURE_OVERFLOW</a>&#160;&#160;&#160;(1UL &lt;&lt; 24)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A new value was captured before the previous value was read, resulting in lost data. </p>

</div>
</div>
<a class="anchor" id="ga043dfcc6d7553b6835e442a00935b070"></a><!-- doxytag: member="tcc.h::TCC_STATUS_CHANNEL_MATCH_CAPTURE" ref="ga043dfcc6d7553b6835e442a00935b070" args="(ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__tcc__group.html#ga043dfcc6d7553b6835e442a00935b070">TCC_STATUS_CHANNEL_MATCH_CAPTURE</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ch</td><td>)</td>
          <td>&#160;&#160;&#160;(1UL &lt;&lt; (ch))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Timer channel <code>ch</code> (0 ~ 3) has matched against its compare value, or has captured a new value. </p>

</div>
</div>
<a class="anchor" id="ga50d80659cbd8ed63a757902b5c11703f"></a><!-- doxytag: member="tcc.h::TCC_STATUS_CHANNEL_OUTPUT" ref="ga50d80659cbd8ed63a757902b5c11703f" args="(ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__tcc__group.html#ga50d80659cbd8ed63a757902b5c11703f">TCC_STATUS_CHANNEL_OUTPUT</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ch</td><td>)</td>
          <td>&#160;&#160;&#160;(1UL &lt;&lt; ((ch)+8))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Timer channel <code>ch</code> (0 ~ 3) match/compare output state. </p>

</div>
</div>
<a class="anchor" id="ga2808c18e7802c7ef3d61f7a7070550c1"></a><!-- doxytag: member="tcc.h::TCC_STATUS_COUNT_OVERFLOW" ref="ga2808c18e7802c7ef3d61f7a7070550c1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__tcc__group.html#ga2808c18e7802c7ef3d61f7a7070550c1">TCC_STATUS_COUNT_OVERFLOW</a>&#160;&#160;&#160;(1UL &lt;&lt; 27)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The timer count value has overflowed from its maximum value to its minimum when counting upward, or from its minimum value to its maximum when counting downward. </p>

</div>
</div>
<a class="anchor" id="ga610153459aac614891331b44983008cb"></a><!-- doxytag: member="tcc.h::TCC_STATUS_COUNTER_EVENT" ref="ga610153459aac614891331b44983008cb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__tcc__group.html#ga610153459aac614891331b44983008cb">TCC_STATUS_COUNTER_EVENT</a>&#160;&#160;&#160;(1UL &lt;&lt; 25)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A counter event occurred. </p>

</div>
</div>
<a class="anchor" id="gaf962f3ea13353cbd80b1fb432e44a668"></a><!-- doxytag: member="tcc.h::TCC_STATUS_COUNTER_RETRIGGERED" ref="gaf962f3ea13353cbd80b1fb432e44a668" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__tcc__group.html#gaf962f3ea13353cbd80b1fb432e44a668">TCC_STATUS_COUNTER_RETRIGGERED</a>&#160;&#160;&#160;(1UL &lt;&lt; 26)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A counter retrigger occurred. </p>

</div>
</div>
<a class="anchor" id="ga3194323a097d8b56b950cfa0fd50ced5"></a><!-- doxytag: member="tcc.h::TCC_STATUS_NON_RECOVERABLE_FAULT_OCCUR" ref="ga3194323a097d8b56b950cfa0fd50ced5" args="(x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__tcc__group.html#ga3194323a097d8b56b950cfa0fd50ced5">TCC_STATUS_NON_RECOVERABLE_FAULT_OCCUR</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(1UL &lt;&lt; ((x)+16))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A Non-Recoverable Fault <code>x</code> (0 ~ 1) has occurred. </p>

</div>
</div>
<a class="anchor" id="ga24d2976610d23257e962e9f58de28390"></a><!-- doxytag: member="tcc.h::TCC_STATUS_NON_RECOVERABLE_FAULT_PRESENT" ref="ga24d2976610d23257e962e9f58de28390" args="(x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__tcc__group.html#ga24d2976610d23257e962e9f58de28390">TCC_STATUS_NON_RECOVERABLE_FAULT_PRESENT</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(1UL &lt;&lt; ((x)+20))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The Non-Recoverable Fault <code>x</code> (0 ~ 1) input is present. </p>

</div>
</div>
<a class="anchor" id="ga3cca37ff8758f5e0954c87f2deae799c"></a><!-- doxytag: member="tcc.h::TCC_STATUS_RAMP_CYCLE_INDEX" ref="ga3cca37ff8758f5e0954c87f2deae799c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__tcc__group.html#ga3cca37ff8758f5e0954c87f2deae799c">TCC_STATUS_RAMP_CYCLE_INDEX</a>&#160;&#160;&#160;(1UL &lt;&lt; 28)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Ramp period cycle index. In ramp operation, each two period cycles are marked as cycle A and B, the index 0 represents cycle A and 1 represents cycle B. </p>

</div>
</div>
<a class="anchor" id="gac99cebef0c7ab79a190e91ce6eada69c"></a><!-- doxytag: member="tcc.h::TCC_STATUS_RECOVERABLE_FAULT_OCCUR" ref="gac99cebef0c7ab79a190e91ce6eada69c" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__tcc__group.html#gac99cebef0c7ab79a190e91ce6eada69c">TCC_STATUS_RECOVERABLE_FAULT_OCCUR</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n</td><td>)</td>
          <td>&#160;&#160;&#160;(1UL &lt;&lt; ((n)+18))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A Recoverable Fault <code>n</code> (0 ~ 1 representing A ~ B) has occured. </p>

</div>
</div>
<a class="anchor" id="ga4c104862376fe400eb02b722827da4b3"></a><!-- doxytag: member="tcc.h::TCC_STATUS_RECOVERABLE_FAULT_PRESENT" ref="ga4c104862376fe400eb02b722827da4b3" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__tcc__group.html#ga4c104862376fe400eb02b722827da4b3">TCC_STATUS_RECOVERABLE_FAULT_PRESENT</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n</td><td>)</td>
          <td>&#160;&#160;&#160;(1UL &lt;&lt; ((n)+22))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A Recoverable Fault <code>n</code> (0 ~ 1 representing A ~ B) is present. </p>

</div>
</div>
<a class="anchor" id="ga253735ed7d35e1747722b246ea97a46d"></a><!-- doxytag: member="tcc.h::TCC_STATUS_STOPPED" ref="ga253735ed7d35e1747722b246ea97a46d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__tcc__group.html#ga253735ed7d35e1747722b246ea97a46d">TCC_STATUS_STOPPED</a>&#160;&#160;&#160;(1UL &lt;&lt; 29)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The counter has been stopped (due to disable, stop command or one-shot). </p>

</div>
</div>
<a class="anchor" id="ga0f4626fd0e09291e69d97889385cd751"></a><!-- doxytag: member="tcc.h::TCC_STATUS_SYNC_READY" ref="ga0f4626fd0e09291e69d97889385cd751" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__asfdoc__sam0__tcc__group.html#ga0f4626fd0e09291e69d97889385cd751">TCC_STATUS_SYNC_READY</a>&#160;&#160;&#160;(1UL &lt;&lt; 23)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Timer registers synchronization has completed, and the synchronized count value may be read. </p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gaa7b829de23a325cdf88764fb0d1f6994"></a><!-- doxytag: member="tcc.h::tcc_callback_t" ref="gaa7b829de23a325cdf88764fb0d1f6994" args=")(struct tcc_module *const module)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="group__asfdoc__sam0__tcc__group.html#gaa7b829de23a325cdf88764fb0d1f6994">tcc_callback_t</a>)(struct <a class="el" href="structtcc__module.html">tcc_module</a> *const module)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Type definition for the TCC callback function. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga36a7de76e8e93ecbeae82cd5667e2eeb"></a><!-- doxytag: member="tcc.h::tcc_callback" ref="ga36a7de76e8e93ecbeae82cd5667e2eeb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tcc__group.html#ga36a7de76e8e93ecbeae82cd5667e2eeb">tcc_callback</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enum for the possible callback types for the TCC module. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga36a7de76e8e93ecbeae82cd5667e2eeba6b9667d1969eae897e336f13055ec6f2"></a><!-- doxytag: member="TCC_CALLBACK_OVERFLOW" ref="gga36a7de76e8e93ecbeae82cd5667e2eeba6b9667d1969eae897e336f13055ec6f2" args="" -->TCC_CALLBACK_OVERFLOW</em>&nbsp;</td><td>
<p>Callback for TCC overflow. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga36a7de76e8e93ecbeae82cd5667e2eeba442e3a9a1d11d76b2a4c060cf45dd8d4"></a><!-- doxytag: member="TCC_CALLBACK_RETRIGGER" ref="gga36a7de76e8e93ecbeae82cd5667e2eeba442e3a9a1d11d76b2a4c060cf45dd8d4" args="" -->TCC_CALLBACK_RETRIGGER</em>&nbsp;</td><td>
<p>Callback for TCC Retrigger. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga36a7de76e8e93ecbeae82cd5667e2eeba835f3af607d0e16468b7c0099163ab27"></a><!-- doxytag: member="TCC_CALLBACK_COUNTER_EVENT" ref="gga36a7de76e8e93ecbeae82cd5667e2eeba835f3af607d0e16468b7c0099163ab27" args="" -->TCC_CALLBACK_COUNTER_EVENT</em>&nbsp;</td><td>
<p>Callback for TCC counter event. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga36a7de76e8e93ecbeae82cd5667e2eeba73b9585a99ef2d625aa21cc4ecedff9c"></a><!-- doxytag: member="TCC_CALLBACK_ERROR" ref="gga36a7de76e8e93ecbeae82cd5667e2eeba73b9585a99ef2d625aa21cc4ecedff9c" args="" -->TCC_CALLBACK_ERROR</em>&nbsp;</td><td>
<p>Callback for capture overflow error. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga36a7de76e8e93ecbeae82cd5667e2eeba338a3e176a8c4be2596143c7f065acf8"></a><!-- doxytag: member="TCC_CALLBACK_FAULTA" ref="gga36a7de76e8e93ecbeae82cd5667e2eeba338a3e176a8c4be2596143c7f065acf8" args="" -->TCC_CALLBACK_FAULTA</em>&nbsp;</td><td>
<p>Callback for Recoverable Fault A. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga36a7de76e8e93ecbeae82cd5667e2eeba38e46ea2ee82304f054b0536cc3d90b8"></a><!-- doxytag: member="TCC_CALLBACK_FAULTB" ref="gga36a7de76e8e93ecbeae82cd5667e2eeba38e46ea2ee82304f054b0536cc3d90b8" args="" -->TCC_CALLBACK_FAULTB</em>&nbsp;</td><td>
<p>Callback for Recoverable Fault B. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga36a7de76e8e93ecbeae82cd5667e2eeba98ceac9bcd0c20f4ed17d89d65ab79c2"></a><!-- doxytag: member="TCC_CALLBACK_FAULT0" ref="gga36a7de76e8e93ecbeae82cd5667e2eeba98ceac9bcd0c20f4ed17d89d65ab79c2" args="" -->TCC_CALLBACK_FAULT0</em>&nbsp;</td><td>
<p>Callback for Non-Recoverable Fault 0. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga36a7de76e8e93ecbeae82cd5667e2eeba0aa610b809e86ad1c813aeaa70691ea1"></a><!-- doxytag: member="TCC_CALLBACK_FAULT1" ref="gga36a7de76e8e93ecbeae82cd5667e2eeba0aa610b809e86ad1c813aeaa70691ea1" args="" -->TCC_CALLBACK_FAULT1</em>&nbsp;</td><td>
<p>Callback for Non-Recoverable Fault 1. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga36a7de76e8e93ecbeae82cd5667e2eebafc4efa0a3bbb81182756228f3bc1b972"></a><!-- doxytag: member="TCC_CALLBACK_N" ref="gga36a7de76e8e93ecbeae82cd5667e2eebafc4efa0a3bbb81182756228f3bc1b972" args="" -->TCC_CALLBACK_N</em>&nbsp;</td><td>
<p>Callbacks for Match/Capture channels, e.g., TCC_CALLBACK_CHANNEL_0. Number of available callbacks. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gaeaa625722173a7f2d75ac1356e8ae840"></a><!-- doxytag: member="tcc.h::tcc_channel_function" ref="gaeaa625722173a7f2d75ac1356e8ae840" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tcc__group.html#gaeaa625722173a7f2d75ac1356e8ae840">tcc_channel_function</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TCC channel operation modes. </p>
<p>To set a timer channel either in compare or in capture mode. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggaeaa625722173a7f2d75ac1356e8ae840a77ef0541a43c84c80a56d26af06f3813"></a><!-- doxytag: member="TCC_CHANNEL_FUNCTION_COMPARE" ref="ggaeaa625722173a7f2d75ac1356e8ae840a77ef0541a43c84c80a56d26af06f3813" args="" -->TCC_CHANNEL_FUNCTION_COMPARE</em>&nbsp;</td><td>
<p>TCC channel performs compare operation. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaeaa625722173a7f2d75ac1356e8ae840acda787d9bb2b779d11b375ad9a525ffb"></a><!-- doxytag: member="TCC_CHANNEL_FUNCTION_CAPTURE" ref="ggaeaa625722173a7f2d75ac1356e8ae840acda787d9bb2b779d11b375ad9a525ffb" args="" -->TCC_CHANNEL_FUNCTION_CAPTURE</em>&nbsp;</td><td>
<p>TCC channel performs capture operation. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga70c3b34ad991069c634a97ec61f52edf"></a><!-- doxytag: member="tcc.h::tcc_clock_prescaler" ref="ga70c3b34ad991069c634a97ec61f52edf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tcc__group.html#ga70c3b34ad991069c634a97ec61f52edf">tcc_clock_prescaler</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TCC clock prescaler values. </p>
<p>This enum is used to choose the clock prescaler configuration. The prescaler divides the clock frequency of the TCC module to operate TCC at a slower clock rate. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga70c3b34ad991069c634a97ec61f52edfab732d492f2700d8937404d6c445008ac"></a><!-- doxytag: member="TCC_CLOCK_PRESCALER_DIV1" ref="gga70c3b34ad991069c634a97ec61f52edfab732d492f2700d8937404d6c445008ac" args="" -->TCC_CLOCK_PRESCALER_DIV1</em>&nbsp;</td><td>
<p>Divide clock by 1. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga70c3b34ad991069c634a97ec61f52edfa4fa7cd62d909645db98258cfc8748c4d"></a><!-- doxytag: member="TCC_CLOCK_PRESCALER_DIV2" ref="gga70c3b34ad991069c634a97ec61f52edfa4fa7cd62d909645db98258cfc8748c4d" args="" -->TCC_CLOCK_PRESCALER_DIV2</em>&nbsp;</td><td>
<p>Divide clock by 2. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga70c3b34ad991069c634a97ec61f52edfac52a69742c42f464bc86612e006155a9"></a><!-- doxytag: member="TCC_CLOCK_PRESCALER_DIV4" ref="gga70c3b34ad991069c634a97ec61f52edfac52a69742c42f464bc86612e006155a9" args="" -->TCC_CLOCK_PRESCALER_DIV4</em>&nbsp;</td><td>
<p>Divide clock by 4. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga70c3b34ad991069c634a97ec61f52edfa0c888826e7d29861159e56fa300d88e5"></a><!-- doxytag: member="TCC_CLOCK_PRESCALER_DIV8" ref="gga70c3b34ad991069c634a97ec61f52edfa0c888826e7d29861159e56fa300d88e5" args="" -->TCC_CLOCK_PRESCALER_DIV8</em>&nbsp;</td><td>
<p>Divide clock by 8. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga70c3b34ad991069c634a97ec61f52edfa10870a7304fc7b7466d8af1f2c777145"></a><!-- doxytag: member="TCC_CLOCK_PRESCALER_DIV16" ref="gga70c3b34ad991069c634a97ec61f52edfa10870a7304fc7b7466d8af1f2c777145" args="" -->TCC_CLOCK_PRESCALER_DIV16</em>&nbsp;</td><td>
<p>Divide clock by 16. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga70c3b34ad991069c634a97ec61f52edfa534a7c3281d31757b70135326a02dfe6"></a><!-- doxytag: member="TCC_CLOCK_PRESCALER_DIV64" ref="gga70c3b34ad991069c634a97ec61f52edfa534a7c3281d31757b70135326a02dfe6" args="" -->TCC_CLOCK_PRESCALER_DIV64</em>&nbsp;</td><td>
<p>Divide clock by 64. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga70c3b34ad991069c634a97ec61f52edfabd31ef941537f7c3f31c75554914f03f"></a><!-- doxytag: member="TCC_CLOCK_PRESCALER_DIV256" ref="gga70c3b34ad991069c634a97ec61f52edfabd31ef941537f7c3f31c75554914f03f" args="" -->TCC_CLOCK_PRESCALER_DIV256</em>&nbsp;</td><td>
<p>Divide clock by 256. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga70c3b34ad991069c634a97ec61f52edfad8d476a749f1a437da36ec9111ac9728"></a><!-- doxytag: member="TCC_CLOCK_PRESCALER_DIV1024" ref="gga70c3b34ad991069c634a97ec61f52edfad8d476a749f1a437da36ec9111ac9728" args="" -->TCC_CLOCK_PRESCALER_DIV1024</em>&nbsp;</td><td>
<p>Divide clock by 1024. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga249b126aed3c60fdbc0e5d00c7174c3c"></a><!-- doxytag: member="tcc.h::tcc_count_direction" ref="ga249b126aed3c60fdbc0e5d00c7174c3c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tcc__group.html#ga249b126aed3c60fdbc0e5d00c7174c3c">tcc_count_direction</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TCC module count direction. </p>
<p>Used when selecting the Timer/Counter count direction. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga249b126aed3c60fdbc0e5d00c7174c3ca3b1fd4ef15ab404e4d2fc37b1761e807"></a><!-- doxytag: member="TCC_COUNT_DIRECTION_UP" ref="gga249b126aed3c60fdbc0e5d00c7174c3ca3b1fd4ef15ab404e4d2fc37b1761e807" args="" -->TCC_COUNT_DIRECTION_UP</em>&nbsp;</td><td>
<p>Timer should count upward. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga249b126aed3c60fdbc0e5d00c7174c3cab59c7a276ce88cfcfde916c982170492"></a><!-- doxytag: member="TCC_COUNT_DIRECTION_DOWN" ref="gga249b126aed3c60fdbc0e5d00c7174c3cab59c7a276ce88cfcfde916c982170492" args="" -->TCC_COUNT_DIRECTION_DOWN</em>&nbsp;</td><td>
<p>Timer should count downward. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gad80cffdb90328129cfa1917a5bb9c61d"></a><!-- doxytag: member="tcc.h::tcc_event0_action" ref="gad80cffdb90328129cfa1917a5bb9c61d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tcc__group.html#gad80cffdb90328129cfa1917a5bb9c61d">tcc_event0_action</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Action to be performed when the TCC module is triggered by event0. </p>
<p>Event action to perform when the module is triggered by event0. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggad80cffdb90328129cfa1917a5bb9c61da388276277ff792915d1017a5950bfb89"></a><!-- doxytag: member="TCC_EVENT0_ACTION_OFF" ref="ggad80cffdb90328129cfa1917a5bb9c61da388276277ff792915d1017a5950bfb89" args="" -->TCC_EVENT0_ACTION_OFF</em>&nbsp;</td><td>
<p>No event action. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad80cffdb90328129cfa1917a5bb9c61da984f4ad2899f9371cf7b81d73b254d3a"></a><!-- doxytag: member="TCC_EVENT0_ACTION_RETRIGGER" ref="ggad80cffdb90328129cfa1917a5bb9c61da984f4ad2899f9371cf7b81d73b254d3a" args="" -->TCC_EVENT0_ACTION_RETRIGGER</em>&nbsp;</td><td>
<p>Re-trigger Counter on event. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad80cffdb90328129cfa1917a5bb9c61da87cfff8a1fd08029c4fdd8b0c70ef3d4"></a><!-- doxytag: member="TCC_EVENT0_ACTION_COUNT_EVENT" ref="ggad80cffdb90328129cfa1917a5bb9c61da87cfff8a1fd08029c4fdd8b0c70ef3d4" args="" -->TCC_EVENT0_ACTION_COUNT_EVENT</em>&nbsp;</td><td>
<p>Count events (increment or decrement, depending on count direction). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad80cffdb90328129cfa1917a5bb9c61daaec5901deb6a5d2ed371d7233a21fefb"></a><!-- doxytag: member="TCC_EVENT0_ACTION_START" ref="ggad80cffdb90328129cfa1917a5bb9c61daaec5901deb6a5d2ed371d7233a21fefb" args="" -->TCC_EVENT0_ACTION_START</em>&nbsp;</td><td>
<p>Start counter on event. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad80cffdb90328129cfa1917a5bb9c61dab6237e36679539d6d99b7ea0046a3d98"></a><!-- doxytag: member="TCC_EVENT0_ACTION_INCREMENT" ref="ggad80cffdb90328129cfa1917a5bb9c61dab6237e36679539d6d99b7ea0046a3d98" args="" -->TCC_EVENT0_ACTION_INCREMENT</em>&nbsp;</td><td>
<p>Increment counter on event. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad80cffdb90328129cfa1917a5bb9c61da3da94c0377525cde8defc0885cb18774"></a><!-- doxytag: member="TCC_EVENT0_ACTION_COUNT_DURING_ACTIVE" ref="ggad80cffdb90328129cfa1917a5bb9c61da3da94c0377525cde8defc0885cb18774" args="" -->TCC_EVENT0_ACTION_COUNT_DURING_ACTIVE</em>&nbsp;</td><td>
<p>Count during active state of asynchronous event. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad80cffdb90328129cfa1917a5bb9c61da3a5f2eff577244d7abb31e5f374fb94b"></a><!-- doxytag: member="TCC_EVENT0_ACTION_NON_RECOVERABLE_FAULT" ref="ggad80cffdb90328129cfa1917a5bb9c61da3a5f2eff577244d7abb31e5f374fb94b" args="" -->TCC_EVENT0_ACTION_NON_RECOVERABLE_FAULT</em>&nbsp;</td><td>
<p>Generate Non-Recoverable Fault on event. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gae28fca3e41f8f09bf573ff0e5a50f9c8"></a><!-- doxytag: member="tcc.h::tcc_event1_action" ref="gae28fca3e41f8f09bf573ff0e5a50f9c8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tcc__group.html#gae28fca3e41f8f09bf573ff0e5a50f9c8">tcc_event1_action</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Action to perform when the TCC module is triggered by event1. </p>
<p>Event action to perform when the module is triggered by event1. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggae28fca3e41f8f09bf573ff0e5a50f9c8afdbcee9dd58cc27696b927c886196fd2"></a><!-- doxytag: member="TCC_EVENT1_ACTION_OFF" ref="ggae28fca3e41f8f09bf573ff0e5a50f9c8afdbcee9dd58cc27696b927c886196fd2" args="" -->TCC_EVENT1_ACTION_OFF</em>&nbsp;</td><td>
<p>No event action. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae28fca3e41f8f09bf573ff0e5a50f9c8a13bb806d58d333a04dd20aae106d8e41"></a><!-- doxytag: member="TCC_EVENT1_ACTION_RETRIGGER" ref="ggae28fca3e41f8f09bf573ff0e5a50f9c8a13bb806d58d333a04dd20aae106d8e41" args="" -->TCC_EVENT1_ACTION_RETRIGGER</em>&nbsp;</td><td>
<p>Re-trigger Counter on event. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae28fca3e41f8f09bf573ff0e5a50f9c8a7355f5535011ffa4a30e44c8da4a75a7"></a><!-- doxytag: member="TCC_EVENT1_ACTION_DIR_CONTROL" ref="ggae28fca3e41f8f09bf573ff0e5a50f9c8a7355f5535011ffa4a30e44c8da4a75a7" args="" -->TCC_EVENT1_ACTION_DIR_CONTROL</em>&nbsp;</td><td>
<p>The event source must be an asynchronous event, input value will override the direction settings. If TCEINVx is 0 and input event is LOW: counter will count up. If TCEINVx is 0 and input event is HIGH: counter will count down. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae28fca3e41f8f09bf573ff0e5a50f9c8a7c326e29775ec2c6f25bb4ecab92d7d2"></a><!-- doxytag: member="TCC_EVENT1_ACTION_STOP" ref="ggae28fca3e41f8f09bf573ff0e5a50f9c8a7c326e29775ec2c6f25bb4ecab92d7d2" args="" -->TCC_EVENT1_ACTION_STOP</em>&nbsp;</td><td>
<p>Stop counter on event. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae28fca3e41f8f09bf573ff0e5a50f9c8af03c20ad157070ed59c09a285e5d55dd"></a><!-- doxytag: member="TCC_EVENT1_ACTION_DECREMENT" ref="ggae28fca3e41f8f09bf573ff0e5a50f9c8af03c20ad157070ed59c09a285e5d55dd" args="" -->TCC_EVENT1_ACTION_DECREMENT</em>&nbsp;</td><td>
<p>Decrement on event. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae28fca3e41f8f09bf573ff0e5a50f9c8ac2303c6c7c2769c465212982dc52fd02"></a><!-- doxytag: member="TCC_EVENT1_ACTION_PERIOD_PULSE_WIDTH_CAPTURE" ref="ggae28fca3e41f8f09bf573ff0e5a50f9c8ac2303c6c7c2769c465212982dc52fd02" args="" -->TCC_EVENT1_ACTION_PERIOD_PULSE_WIDTH_CAPTURE</em>&nbsp;</td><td>
<p>Store period in capture register 0, pulse width in capture register 1. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae28fca3e41f8f09bf573ff0e5a50f9c8a94654078df98319b89a1548e7cdcbd56"></a><!-- doxytag: member="TCC_EVENT1_ACTION_PULSE_WIDTH_PERIOD_CAPTURE" ref="ggae28fca3e41f8f09bf573ff0e5a50f9c8a94654078df98319b89a1548e7cdcbd56" args="" -->TCC_EVENT1_ACTION_PULSE_WIDTH_PERIOD_CAPTURE</em>&nbsp;</td><td>
<p>Store pulse width in capture register 0, period in capture register 1. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae28fca3e41f8f09bf573ff0e5a50f9c8a9b52632f222313ee66ee042423a6d846"></a><!-- doxytag: member="TCC_EVENT1_ACTION_NON_RECOVERABLE_FAULT" ref="ggae28fca3e41f8f09bf573ff0e5a50f9c8a9b52632f222313ee66ee042423a6d846" args="" -->TCC_EVENT1_ACTION_NON_RECOVERABLE_FAULT</em>&nbsp;</td><td>
<p>Generate Non-Recoverable Fault on event. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gaaa34ddec58a743f0b079ed882bd7fa02"></a><!-- doxytag: member="tcc.h::tcc_event_action" ref="gaaa34ddec58a743f0b079ed882bd7fa02" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tcc__group.html#gaaa34ddec58a743f0b079ed882bd7fa02">tcc_event_action</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Action to perform when the TCC module is triggered by events. </p>
<p>Event action to perform when the module is triggered by events. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggaaa34ddec58a743f0b079ed882bd7fa02af05ae1f179159ae33abbf1637183d6dc"></a><!-- doxytag: member="TCC_EVENT_ACTION_OFF" ref="ggaaa34ddec58a743f0b079ed882bd7fa02af05ae1f179159ae33abbf1637183d6dc" args="" -->TCC_EVENT_ACTION_OFF</em>&nbsp;</td><td>
<p>No event action. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaaa34ddec58a743f0b079ed882bd7fa02a346ce4e970f712a026be939342dc92b7"></a><!-- doxytag: member="TCC_EVENT_ACTION_STOP" ref="ggaaa34ddec58a743f0b079ed882bd7fa02a346ce4e970f712a026be939342dc92b7" args="" -->TCC_EVENT_ACTION_STOP</em>&nbsp;</td><td>
<p>Stop counting, the counter will maintain its current value, waveforms are set to a defined Non-Recoverable State output (tcc_non_recoverable_state_output). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaaa34ddec58a743f0b079ed882bd7fa02a64e6b5c1baa9d4e718c40e3be753406e"></a><!-- doxytag: member="TCC_EVENT_ACTION_RETRIGGER" ref="ggaaa34ddec58a743f0b079ed882bd7fa02a64e6b5c1baa9d4e718c40e3be753406e" args="" -->TCC_EVENT_ACTION_RETRIGGER</em>&nbsp;</td><td>
<p>Re-trigger counter on event, may generate an event if the re-trigger event output is enabled. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>When re-trigger event action is enabled, enabling the counter will not start until the next incoming event appears. </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaaa34ddec58a743f0b079ed882bd7fa02a40edb508b1059e53e9eeb787810c2f51"></a><!-- doxytag: member="TCC_EVENT_ACTION_START" ref="ggaaa34ddec58a743f0b079ed882bd7fa02a40edb508b1059e53e9eeb787810c2f51" args="" -->TCC_EVENT_ACTION_START</em>&nbsp;</td><td>
<p>Start counter when previously stopped. Start counting on the event rising edge. Further events will not restart the counter; the counter keeps on counting using prescaled GCLK_TCCx, until it reaches TOP or Zero depending on the direction. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaaa34ddec58a743f0b079ed882bd7fa02a15216a830e8a5c495bef4fc088fc25df"></a><!-- doxytag: member="TCC_EVENT_ACTION_COUNT_EVENT" ref="ggaaa34ddec58a743f0b079ed882bd7fa02a15216a830e8a5c495bef4fc088fc25df" args="" -->TCC_EVENT_ACTION_COUNT_EVENT</em>&nbsp;</td><td>
<p>Count events; i.e. Increment or decrement depending on count direction. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaaa34ddec58a743f0b079ed882bd7fa02ac6a9f1ee37929a715d5010431b9836d4"></a><!-- doxytag: member="TCC_EVENT_ACTION_DIR_CONTROL" ref="ggaaa34ddec58a743f0b079ed882bd7fa02ac6a9f1ee37929a715d5010431b9836d4" args="" -->TCC_EVENT_ACTION_DIR_CONTROL</em>&nbsp;</td><td>
<p>The event source must be an asynchronous event, input value will overrides the direction settings (input low: counting up, input high counting down). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaaa34ddec58a743f0b079ed882bd7fa02a8a2b0db66b4f0614b3c87e4e1f7e0c14"></a><!-- doxytag: member="TCC_EVENT_ACTION_INCREMENT" ref="ggaaa34ddec58a743f0b079ed882bd7fa02a8a2b0db66b4f0614b3c87e4e1f7e0c14" args="" -->TCC_EVENT_ACTION_INCREMENT</em>&nbsp;</td><td>
<p>Increment the counter on event, irrespective of count direction. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaaa34ddec58a743f0b079ed882bd7fa02aeb1f6b4fcedd8dc68f0817ec55176b41"></a><!-- doxytag: member="TCC_EVENT_ACTION_DECREMENT" ref="ggaaa34ddec58a743f0b079ed882bd7fa02aeb1f6b4fcedd8dc68f0817ec55176b41" args="" -->TCC_EVENT_ACTION_DECREMENT</em>&nbsp;</td><td>
<p>Decrement the counter on event, irrespective of count direction. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaaa34ddec58a743f0b079ed882bd7fa02a5c474138a0666f6c0f5bbc93a9f01d80"></a><!-- doxytag: member="TCC_EVENT_ACTION_COUNT_DURING_ACTIVE" ref="ggaaa34ddec58a743f0b079ed882bd7fa02a5c474138a0666f6c0f5bbc93a9f01d80" args="" -->TCC_EVENT_ACTION_COUNT_DURING_ACTIVE</em>&nbsp;</td><td>
<p>Count during active state of asynchronous event. In this case, depending on the count direction, the count will be incremented or decremented on each prescaled GCLK_TCCx, as long as the input event remains active. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaaa34ddec58a743f0b079ed882bd7fa02a72631c0be6ff182cf0123de1f1512a25"></a><!-- doxytag: member="TCC_EVENT_ACTION_PERIOD_PULSE_WIDTH_CAPTURE" ref="ggaaa34ddec58a743f0b079ed882bd7fa02a72631c0be6ff182cf0123de1f1512a25" args="" -->TCC_EVENT_ACTION_PERIOD_PULSE_WIDTH_CAPTURE</em>&nbsp;</td><td>
<p>Store period in capture register 0, pulse width in capture register 1. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaaa34ddec58a743f0b079ed882bd7fa02afa2722b2a4fe7638622116dff3e5316d"></a><!-- doxytag: member="TCC_EVENT_ACTION_PULSE_WIDTH_PERIOD_CAPTURE" ref="ggaaa34ddec58a743f0b079ed882bd7fa02afa2722b2a4fe7638622116dff3e5316d" args="" -->TCC_EVENT_ACTION_PULSE_WIDTH_PERIOD_CAPTURE</em>&nbsp;</td><td>
<p>Store pulse width in capture register 0, period in capture register 1. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaaa34ddec58a743f0b079ed882bd7fa02a820646e92211693414a7a4e740510bb4"></a><!-- doxytag: member="TCC_EVENT_ACTION_NON_RECOVERABLE_FAULT" ref="ggaaa34ddec58a743f0b079ed882bd7fa02a820646e92211693414a7a4e740510bb4" args="" -->TCC_EVENT_ACTION_NON_RECOVERABLE_FAULT</em>&nbsp;</td><td>
<p>Generate Non-Recoverable Fault on event. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gae5d84230d25f8a38f2fb420fb9480383"></a><!-- doxytag: member="tcc.h::tcc_event_generation_selection" ref="gae5d84230d25f8a38f2fb420fb9480383" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tcc__group.html#gae5d84230d25f8a38f2fb420fb9480383">tcc_event_generation_selection</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>On which part of the counter cycle the counter event output is generated. </p>
<p>This enum is used to define the point at which the counter event is generated. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggae5d84230d25f8a38f2fb420fb9480383a888a715219e4a10865a8dbb13e6dc4da"></a><!-- doxytag: member="TCC_EVENT_GENERATION_SELECTION_START" ref="ggae5d84230d25f8a38f2fb420fb9480383a888a715219e4a10865a8dbb13e6dc4da" args="" -->TCC_EVENT_GENERATION_SELECTION_START</em>&nbsp;</td><td>
<p>Counter Event is generated when a new counter cycle starts. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae5d84230d25f8a38f2fb420fb9480383a09be4a3bc53fff81d9bf5d8333204540"></a><!-- doxytag: member="TCC_EVENT_GENERATION_SELECTION_END" ref="ggae5d84230d25f8a38f2fb420fb9480383a09be4a3bc53fff81d9bf5d8333204540" args="" -->TCC_EVENT_GENERATION_SELECTION_END</em>&nbsp;</td><td>
<p>Counter Event is generated when a counter cycle ends. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae5d84230d25f8a38f2fb420fb9480383aafe4aada27c0d416d4190d726b49c964"></a><!-- doxytag: member="TCC_EVENT_GENERATION_SELECTION_BETWEEN" ref="ggae5d84230d25f8a38f2fb420fb9480383aafe4aada27c0d416d4190d726b49c964" args="" -->TCC_EVENT_GENERATION_SELECTION_BETWEEN</em>&nbsp;</td><td>
<p>Counter Event is generated when a counter cycle ends, except for the first and last cycles. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae5d84230d25f8a38f2fb420fb9480383a1cbde3ae103e3093714fbf63b70b3435"></a><!-- doxytag: member="TCC_EVENT_GENERATION_SELECTION_BOUNDARY" ref="ggae5d84230d25f8a38f2fb420fb9480383a1cbde3ae103e3093714fbf63b70b3435" args="" -->TCC_EVENT_GENERATION_SELECTION_BOUNDARY</em>&nbsp;</td><td>
<p>Counter Event is generated when a new counter cycle starts or ends. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gafef8af6ab243449286fef8e55b1b6363"></a><!-- doxytag: member="tcc.h::tcc_fault_blanking" ref="gafef8af6ab243449286fef8e55b1b6363" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tcc__group.html#gafef8af6ab243449286fef8e55b1b6363">tcc_fault_blanking</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TCC (recoverable) fault Input Blanking Start Point. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggafef8af6ab243449286fef8e55b1b6363abc18836dec5fc7d3d790d3b08ef8729c"></a><!-- doxytag: member="TCC_FAULT_BLANKING_DISABLE" ref="ggafef8af6ab243449286fef8e55b1b6363abc18836dec5fc7d3d790d3b08ef8729c" args="" -->TCC_FAULT_BLANKING_DISABLE</em>&nbsp;</td><td>
<p>No blanking. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggafef8af6ab243449286fef8e55b1b6363acad16d518e77af4446e81d16c13f67f3"></a><!-- doxytag: member="TCC_FAULT_BLANKING_RISING_EDGE" ref="ggafef8af6ab243449286fef8e55b1b6363acad16d518e77af4446e81d16c13f67f3" args="" -->TCC_FAULT_BLANKING_RISING_EDGE</em>&nbsp;</td><td>
<p>Blanking applied from rising edge of the output waveform. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggafef8af6ab243449286fef8e55b1b6363a1df053892368d1874c83b168d023e7ab"></a><!-- doxytag: member="TCC_FAULT_BLANKING_FALLING_EDGE" ref="ggafef8af6ab243449286fef8e55b1b6363a1df053892368d1874c83b168d023e7ab" args="" -->TCC_FAULT_BLANKING_FALLING_EDGE</em>&nbsp;</td><td>
<p>Blanking applied from falling edge of the output waveform. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggafef8af6ab243449286fef8e55b1b6363a59a2c695ad9e24f8e3ea4dfb5e18dd4c"></a><!-- doxytag: member="TCC_FAULT_BLANKING_BOTH_EDGE" ref="ggafef8af6ab243449286fef8e55b1b6363a59a2c695ad9e24f8e3ea4dfb5e18dd4c" args="" -->TCC_FAULT_BLANKING_BOTH_EDGE</em>&nbsp;</td><td>
<p>Blanking applied from each toggle of the output waveform. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga717a45534e91262d6633f12ff13e6089"></a><!-- doxytag: member="tcc.h::tcc_fault_capture_action" ref="ga717a45534e91262d6633f12ff13e6089" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tcc__group.html#ga717a45534e91262d6633f12ff13e6089">tcc_fault_capture_action</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TCC (recoverable) fault Capture action. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga717a45534e91262d6633f12ff13e6089aa10b402bd4d4ba19f89a0d10867bc2f9"></a><!-- doxytag: member="TCC_FAULT_CAPTURE_DISABLE" ref="gga717a45534e91262d6633f12ff13e6089aa10b402bd4d4ba19f89a0d10867bc2f9" args="" -->TCC_FAULT_CAPTURE_DISABLE</em>&nbsp;</td><td>
<p>Capture disabled. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga717a45534e91262d6633f12ff13e6089a1fbcf718db17a9717ae725acc2127431"></a><!-- doxytag: member="TCC_FAULT_CAPTURE_EACH" ref="gga717a45534e91262d6633f12ff13e6089a1fbcf718db17a9717ae725acc2127431" args="" -->TCC_FAULT_CAPTURE_EACH</em>&nbsp;</td><td>
<p>Capture on Fault, each value is captured. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga717a45534e91262d6633f12ff13e6089a7ba4b230f6d38522c28fac8fae666211"></a><!-- doxytag: member="TCC_FAULT_CAPTURE_MINIMUM" ref="gga717a45534e91262d6633f12ff13e6089a7ba4b230f6d38522c28fac8fae666211" args="" -->TCC_FAULT_CAPTURE_MINIMUM</em>&nbsp;</td><td>
<p>Capture the minimum detection, but notify on smaller ones. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga717a45534e91262d6633f12ff13e6089a8e7d43d838c58991ea2d09501094ed0a"></a><!-- doxytag: member="TCC_FAULT_CAPTURE_MAXIMUM" ref="gga717a45534e91262d6633f12ff13e6089a8e7d43d838c58991ea2d09501094ed0a" args="" -->TCC_FAULT_CAPTURE_MAXIMUM</em>&nbsp;</td><td>
<p>Capture the maximum detection, but notify on bigger ones. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga717a45534e91262d6633f12ff13e6089a5fdfb48df41a86fd830abe0a8aab34ba"></a><!-- doxytag: member="TCC_FAULT_CAPTURE_SMALLER" ref="gga717a45534e91262d6633f12ff13e6089a5fdfb48df41a86fd830abe0a8aab34ba" args="" -->TCC_FAULT_CAPTURE_SMALLER</em>&nbsp;</td><td>
<p>Capture if the value is smaller than last, notify event or interrupt if previous stamp is confirmed to be "local minimum" (not bigger than current stamp). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga717a45534e91262d6633f12ff13e6089adf520e91c4781ef402c3b93e0d94f098"></a><!-- doxytag: member="TCC_FAULT_CAPTURE_BIGGER" ref="gga717a45534e91262d6633f12ff13e6089adf520e91c4781ef402c3b93e0d94f098" args="" -->TCC_FAULT_CAPTURE_BIGGER</em>&nbsp;</td><td>
<p>Capture if the value is bigger than last, notify event or interrupt if previous stamp is confirmed to be "local maximum" (not smaller than current stamp). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga717a45534e91262d6633f12ff13e6089a4841c2b9b65527867ec63dbddb814201"></a><!-- doxytag: member="TCC_FAULT_CAPTURE_CHANGE" ref="gga717a45534e91262d6633f12ff13e6089a4841c2b9b65527867ec63dbddb814201" args="" -->TCC_FAULT_CAPTURE_CHANGE</em>&nbsp;</td><td>
<p>Capture if the time stamps changes its increment direction. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa2a1f2c8fe209042dd51c1667ed9d0ce"></a><!-- doxytag: member="tcc.h::tcc_fault_capture_channel" ref="gaa2a1f2c8fe209042dd51c1667ed9d0ce" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tcc__group.html#gaa2a1f2c8fe209042dd51c1667ed9d0ce">tcc_fault_capture_channel</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Capture Channel triggered by TCC (recoverable) fault. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggaa2a1f2c8fe209042dd51c1667ed9d0cea441e0349c9f7d97de4cd79791c3534e1"></a><!-- doxytag: member="TCC_FAULT_CAPTURE_CHANNEL_0" ref="ggaa2a1f2c8fe209042dd51c1667ed9d0cea441e0349c9f7d97de4cd79791c3534e1" args="" -->TCC_FAULT_CAPTURE_CHANNEL_0</em>&nbsp;</td><td>
<p>Recoverable fault triggers channel 0 capture operation. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa2a1f2c8fe209042dd51c1667ed9d0ceae5498f30d4e119cb333bb46112f0c8e3"></a><!-- doxytag: member="TCC_FAULT_CAPTURE_CHANNEL_1" ref="ggaa2a1f2c8fe209042dd51c1667ed9d0ceae5498f30d4e119cb333bb46112f0c8e3" args="" -->TCC_FAULT_CAPTURE_CHANNEL_1</em>&nbsp;</td><td>
<p>Recoverable fault triggers channel 1 capture operation. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa2a1f2c8fe209042dd51c1667ed9d0ceacc18e785914ed026fa59da4703dbeeeb"></a><!-- doxytag: member="TCC_FAULT_CAPTURE_CHANNEL_2" ref="ggaa2a1f2c8fe209042dd51c1667ed9d0ceacc18e785914ed026fa59da4703dbeeeb" args="" -->TCC_FAULT_CAPTURE_CHANNEL_2</em>&nbsp;</td><td>
<p>Recoverable fault triggers channel 2 capture operation. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa2a1f2c8fe209042dd51c1667ed9d0cea77a47b6923340d09df54e606ee1b404f"></a><!-- doxytag: member="TCC_FAULT_CAPTURE_CHANNEL_3" ref="ggaa2a1f2c8fe209042dd51c1667ed9d0cea77a47b6923340d09df54e606ee1b404f" args="" -->TCC_FAULT_CAPTURE_CHANNEL_3</em>&nbsp;</td><td>
<p>Recoverable fault triggers channel 3 capture operation. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1391584a88af0ec6114c29ca469285b3"></a><!-- doxytag: member="tcc.h::tcc_fault_halt_action" ref="ga1391584a88af0ec6114c29ca469285b3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tcc__group.html#ga1391584a88af0ec6114c29ca469285b3">tcc_fault_halt_action</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TCC (recoverable) fault Halt action. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga1391584a88af0ec6114c29ca469285b3a4e37d085c8dbe7be8a93ea50ee2b5104"></a><!-- doxytag: member="TCC_FAULT_HALT_ACTION_DISABLE" ref="gga1391584a88af0ec6114c29ca469285b3a4e37d085c8dbe7be8a93ea50ee2b5104" args="" -->TCC_FAULT_HALT_ACTION_DISABLE</em>&nbsp;</td><td>
<p>Halt action disabled. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga1391584a88af0ec6114c29ca469285b3ac95bd7272d2fdb799e61cc5c59c415ec"></a><!-- doxytag: member="TCC_FAULT_HALT_ACTION_HW_HALT" ref="gga1391584a88af0ec6114c29ca469285b3ac95bd7272d2fdb799e61cc5c59c415ec" args="" -->TCC_FAULT_HALT_ACTION_HW_HALT</em>&nbsp;</td><td>
<p>Hardware halt action, counter is halted until restart. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga1391584a88af0ec6114c29ca469285b3a49ed4ee870ef6a399883f45e0232f7fb"></a><!-- doxytag: member="TCC_FAULT_HALT_ACTION_SW_HALT" ref="gga1391584a88af0ec6114c29ca469285b3a49ed4ee870ef6a399883f45e0232f7fb" args="" -->TCC_FAULT_HALT_ACTION_SW_HALT</em>&nbsp;</td><td>
<p>Software halt action, counter is halted until fault bit cleared. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga1391584a88af0ec6114c29ca469285b3a36c7d81023fd3f9b60291edba83239f1"></a><!-- doxytag: member="TCC_FAULT_HALT_ACTION_NON_RECOVERABLE" ref="gga1391584a88af0ec6114c29ca469285b3a36c7d81023fd3f9b60291edba83239f1" args="" -->TCC_FAULT_HALT_ACTION_NON_RECOVERABLE</em>&nbsp;</td><td>
<p>Non-Recoverable fault, force output to pre-defined level. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gabb474178919742afb4aa6c5e2d311c8c"></a><!-- doxytag: member="tcc.h::tcc_fault_keep" ref="gabb474178919742afb4aa6c5e2d311c8c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tcc__group.html#gabb474178919742afb4aa6c5e2d311c8c">tcc_fault_keep</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TCC (recoverable) fault Output Keep Action. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggabb474178919742afb4aa6c5e2d311c8cacfea32367135e975dd7ed631ef66f385"></a><!-- doxytag: member="TCC_FAULT_KEEP_DISABLE" ref="ggabb474178919742afb4aa6c5e2d311c8cacfea32367135e975dd7ed631ef66f385" args="" -->TCC_FAULT_KEEP_DISABLE</em>&nbsp;</td><td>
<p>Disable keeping, wave output released as soon as fault is released. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggabb474178919742afb4aa6c5e2d311c8ca1f79015009bf985ae7182241a75bb9b3"></a><!-- doxytag: member="TCC_FAULT_KEEP_TILL_END" ref="ggabb474178919742afb4aa6c5e2d311c8ca1f79015009bf985ae7182241a75bb9b3" args="" -->TCC_FAULT_KEEP_TILL_END</em>&nbsp;</td><td>
<p>Keep wave output until end of TCC cycle. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gab8eaffb29665b7f55a822a0aaae4e494"></a><!-- doxytag: member="tcc.h::tcc_fault_qualification" ref="gab8eaffb29665b7f55a822a0aaae4e494" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tcc__group.html#gab8eaffb29665b7f55a822a0aaae4e494">tcc_fault_qualification</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TCC (recoverable) fault Input Qualification Action. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggab8eaffb29665b7f55a822a0aaae4e494ae03b24cc21739972b3d79f75c23622ab"></a><!-- doxytag: member="TCC_FAULT_QUALIFICATION_DISABLE" ref="ggab8eaffb29665b7f55a822a0aaae4e494ae03b24cc21739972b3d79f75c23622ab" args="" -->TCC_FAULT_QUALIFICATION_DISABLE</em>&nbsp;</td><td>
<p>The input is not disabled on compare condition. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab8eaffb29665b7f55a822a0aaae4e494a29e06986875af6af970573f1a780a456"></a><!-- doxytag: member="TCC_FAULT_QUALIFICATION_BY_OUTPUT" ref="ggab8eaffb29665b7f55a822a0aaae4e494a29e06986875af6af970573f1a780a456" args="" -->TCC_FAULT_QUALIFICATION_BY_OUTPUT</em>&nbsp;</td><td>
<p>The input is disabled when match output signal is at inactive level. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gab097e6632653be4b5ae56c011423b3a3"></a><!-- doxytag: member="tcc.h::tcc_fault_restart" ref="gab097e6632653be4b5ae56c011423b3a3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tcc__group.html#gab097e6632653be4b5ae56c011423b3a3">tcc_fault_restart</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TCC (recoverable) fault Restart Action. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggab097e6632653be4b5ae56c011423b3a3af5b6bef00fc0413143e42778a33e1a6f"></a><!-- doxytag: member="TCC_FAULT_RESTART_DISABLE" ref="ggab097e6632653be4b5ae56c011423b3a3af5b6bef00fc0413143e42778a33e1a6f" args="" -->TCC_FAULT_RESTART_DISABLE</em>&nbsp;</td><td>
<p>Restart Action disabled. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab097e6632653be4b5ae56c011423b3a3a419bc4ac915713b649e3c28c750d6941"></a><!-- doxytag: member="TCC_FAULT_RESTART_ENABLE" ref="ggab097e6632653be4b5ae56c011423b3a3a419bc4ac915713b649e3c28c750d6941" args="" -->TCC_FAULT_RESTART_ENABLE</em>&nbsp;</td><td>
<p>Restart Action enabled. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5284d364c10d209e5f8514cf950f1091"></a><!-- doxytag: member="tcc.h::tcc_fault_source" ref="ga5284d364c10d209e5f8514cf950f1091" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tcc__group.html#ga5284d364c10d209e5f8514cf950f1091">tcc_fault_source</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TCC (recoverable) fault Input Source. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga5284d364c10d209e5f8514cf950f1091a5c73948a12b2bd2b5992a651435474bc"></a><!-- doxytag: member="TCC_FAULT_SOURCE_DISABLE" ref="gga5284d364c10d209e5f8514cf950f1091a5c73948a12b2bd2b5992a651435474bc" args="" -->TCC_FAULT_SOURCE_DISABLE</em>&nbsp;</td><td>
<p>Fault input is disabled. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga5284d364c10d209e5f8514cf950f1091a7216e4a2f377b9aa3e9574bf512447b6"></a><!-- doxytag: member="TCC_FAULT_SOURCE_ENABLE" ref="gga5284d364c10d209e5f8514cf950f1091a7216e4a2f377b9aa3e9574bf512447b6" args="" -->TCC_FAULT_SOURCE_ENABLE</em>&nbsp;</td><td>
<p>Match Capture Event x (x=0,1) input. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga5284d364c10d209e5f8514cf950f1091a93bbdfe094463eca72b800ad118fb035"></a><!-- doxytag: member="TCC_FAULT_SOURCE_INVERT" ref="gga5284d364c10d209e5f8514cf950f1091a93bbdfe094463eca72b800ad118fb035" args="" -->TCC_FAULT_SOURCE_INVERT</em>&nbsp;</td><td>
<p>Inverted MCEx (x=0,1) event input. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga5284d364c10d209e5f8514cf950f1091a74573ab6554f700ee248e9b92dbc34ca"></a><!-- doxytag: member="TCC_FAULT_SOURCE_ALTFAULT" ref="gga5284d364c10d209e5f8514cf950f1091a74573ab6554f700ee248e9b92dbc34ca" args="" -->TCC_FAULT_SOURCE_ALTFAULT</em>&nbsp;</td><td>
<p>Alternate fault (A or B) state at the end of the previous period. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gaef8e2c6de33a11029ffaf0fc2011f118"></a><!-- doxytag: member="tcc.h::tcc_fault_state_output" ref="gaef8e2c6de33a11029ffaf0fc2011f118" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tcc__group.html#gaef8e2c6de33a11029ffaf0fc2011f118">tcc_fault_state_output</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TCC Non-recoverable State Outupt. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggaef8e2c6de33a11029ffaf0fc2011f118a9ac9783b62d1fae4b066259b93d85282"></a><!-- doxytag: member="TCC_FAULT_STATE_OUTPUT_OFF" ref="ggaef8e2c6de33a11029ffaf0fc2011f118a9ac9783b62d1fae4b066259b93d85282" args="" -->TCC_FAULT_STATE_OUTPUT_OFF</em>&nbsp;</td><td>
<p>Non-recoverable fault output is tri-stated. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaef8e2c6de33a11029ffaf0fc2011f118aac863b3a350db4e9d4c269bf0a3dc397"></a><!-- doxytag: member="TCC_FAULT_STATE_OUTPUT_0" ref="ggaef8e2c6de33a11029ffaf0fc2011f118aac863b3a350db4e9d4c269bf0a3dc397" args="" -->TCC_FAULT_STATE_OUTPUT_0</em>&nbsp;</td><td>
<p>Non-recoverable fault force output 0. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaef8e2c6de33a11029ffaf0fc2011f118a4354f291aac34dd8ee1e8a2f125b308b"></a><!-- doxytag: member="TCC_FAULT_STATE_OUTPUT_1" ref="ggaef8e2c6de33a11029ffaf0fc2011f118a4354f291aac34dd8ee1e8a2f125b308b" args="" -->TCC_FAULT_STATE_OUTPUT_1</em>&nbsp;</td><td>
<p>Non-recoverable fault force output 1. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf0ea531eacd92224d87ebdaf63db6c86"></a><!-- doxytag: member="tcc.h::tcc_match_capture_channel" ref="gaf0ea531eacd92224d87ebdaf63db6c86" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tcc__group.html#gaf0ea531eacd92224d87ebdaf63db6c86">tcc_match_capture_channel</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Index of the match capture channels. </p>
<p>This enum is used to specify which capture/match channel to do operations on. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggaf0ea531eacd92224d87ebdaf63db6c86af731a3af6f1bf07648bfe3b632be6706"></a><!-- doxytag: member="TCC_MATCH_CAPTURE_CHANNEL_N" ref="ggaf0ea531eacd92224d87ebdaf63db6c86af731a3af6f1bf07648bfe3b632be6706" args="" -->TCC_MATCH_CAPTURE_CHANNEL_N</em>&nbsp;</td><td>
<p>Indexes of match capture channels, e.g., TCC_MATCH_CAPTURE_CHANNEL_0. Number of supported channels. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga91a7590776909b314bf8b2d380db25f2"></a><!-- doxytag: member="tcc.h::tcc_output_invertion" ref="ga91a7590776909b314bf8b2d380db25f2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tcc__group.html#ga91a7590776909b314bf8b2d380db25f2">tcc_output_invertion</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TCC output inversion. </p>
<p>Used when enabling or disabling output inversion. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga91a7590776909b314bf8b2d380db25f2a82021056838ce19baddfa2c26cbf7928"></a><!-- doxytag: member="TCC_OUTPUT_INVERTION_DISABLE" ref="gga91a7590776909b314bf8b2d380db25f2a82021056838ce19baddfa2c26cbf7928" args="" -->TCC_OUTPUT_INVERTION_DISABLE</em>&nbsp;</td><td>
<p>Output inversion not to be enabled. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga91a7590776909b314bf8b2d380db25f2a19d555910cf6a29718737f5f5391d7de"></a><!-- doxytag: member="TCC_OUTPUT_INVERTION_ENABLE" ref="gga91a7590776909b314bf8b2d380db25f2a19d555910cf6a29718737f5f5391d7de" args="" -->TCC_OUTPUT_INVERTION_ENABLE</em>&nbsp;</td><td>
<p>Invert the output from WO[x]. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gae308e9eeb120db42f773f680118fe340"></a><!-- doxytag: member="tcc.h::tcc_output_pattern" ref="gae308e9eeb120db42f773f680118fe340" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tcc__group.html#gae308e9eeb120db42f773f680118fe340">tcc_output_pattern</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TCC pattern generator for outputs. </p>
<p>Used when disabling output pattern or when selecting a specific pattern. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggae308e9eeb120db42f773f680118fe340a0f4c63e8ade521fd775b593432395522"></a><!-- doxytag: member="TCC_OUTPUT_PATTERN_DISABLE" ref="ggae308e9eeb120db42f773f680118fe340a0f4c63e8ade521fd775b593432395522" args="" -->TCC_OUTPUT_PATTERN_DISABLE</em>&nbsp;</td><td>
<p>SWAP output pattern is not used. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae308e9eeb120db42f773f680118fe340ac6a635e4d036e7d6fda1f0a523662a3e"></a><!-- doxytag: member="TCC_OUTPUT_PATTERN_0" ref="ggae308e9eeb120db42f773f680118fe340ac6a635e4d036e7d6fda1f0a523662a3e" args="" -->TCC_OUTPUT_PATTERN_0</em>&nbsp;</td><td>
<p>Pattern 0 is applied to SWAP output. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae308e9eeb120db42f773f680118fe340a1495634d6a9e8921522886b67e29624c"></a><!-- doxytag: member="TCC_OUTPUT_PATTERN_1" ref="ggae308e9eeb120db42f773f680118fe340a1495634d6a9e8921522886b67e29624c" args="" -->TCC_OUTPUT_PATTERN_1</em>&nbsp;</td><td>
<p>Pattern 1 is applied to SWAP output. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga34e5c70c51742be434fb76aee0e9efdb"></a><!-- doxytag: member="tcc.h::tcc_ramp" ref="ga34e5c70c51742be434fb76aee0e9efdb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tcc__group.html#ga34e5c70c51742be434fb76aee0e9efdb">tcc_ramp</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ramp Operations which are supported in single-slope PWM generation. </p>
<p>Ramp operations which are supported in single-slope PWM generation. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga34e5c70c51742be434fb76aee0e9efdbaac8e00b72dd45b706c20d22d4d82a608"></a><!-- doxytag: member="TCC_RAMP_RAMP1" ref="gga34e5c70c51742be434fb76aee0e9efdbaac8e00b72dd45b706c20d22d4d82a608" args="" -->TCC_RAMP_RAMP1</em>&nbsp;</td><td>
<p>Default timer/counter PWM operation. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga34e5c70c51742be434fb76aee0e9efdba70b3f4234e9ce2d0a686332d1585b907"></a><!-- doxytag: member="TCC_RAMP_RAMP2A" ref="gga34e5c70c51742be434fb76aee0e9efdba70b3f4234e9ce2d0a686332d1585b907" args="" -->TCC_RAMP_RAMP2A</em>&nbsp;</td><td>
<p>Uses a single channel (CC0) to control both CC0/CC1 compare outputs. In cycle A, the channel 0 output is disabled, and in cycle B, the channel 1 output is disabled. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga34e5c70c51742be434fb76aee0e9efdba14a8cca97df1ae7a4a17382a2ae95fca"></a><!-- doxytag: member="TCC_RAMP_RAMP2" ref="gga34e5c70c51742be434fb76aee0e9efdba14a8cca97df1ae7a4a17382a2ae95fca" args="" -->TCC_RAMP_RAMP2</em>&nbsp;</td><td>
<p>Uses channels CC0 and CC1 to control compare outputs. In cycle A, the channel 0 output is disabled, and in cycle B, the channel 1 output is disabled. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga00764af4bfa719981b2a4f6e224dd9c1"></a><!-- doxytag: member="tcc.h::tcc_ramp_index" ref="ga00764af4bfa719981b2a4f6e224dd9c1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tcc__group.html#ga00764af4bfa719981b2a4f6e224dd9c1">tcc_ramp_index</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ramp Index for TCC wave generation. </p>
<p>In ramp operation, each two period cycles are marked as cycle A and B, the index 0 represents cycle A and 1 represents cycle B. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga00764af4bfa719981b2a4f6e224dd9c1afd3b9a8e71c199b3658b1083af2a5380"></a><!-- doxytag: member="TCC_RAMP_INDEX_DEFAULT" ref="gga00764af4bfa719981b2a4f6e224dd9c1afd3b9a8e71c199b3658b1083af2a5380" args="" -->TCC_RAMP_INDEX_DEFAULT</em>&nbsp;</td><td>
<p>Default, cycle index toggles. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga00764af4bfa719981b2a4f6e224dd9c1ae76a5e98f57968d2dcef6dbd5bf3c90a"></a><!-- doxytag: member="TCC_RAMP_INDEX_FORCE_B" ref="gga00764af4bfa719981b2a4f6e224dd9c1ae76a5e98f57968d2dcef6dbd5bf3c90a" args="" -->TCC_RAMP_INDEX_FORCE_B</em>&nbsp;</td><td>
<p>Force next cycle to be cycle B (set to 1). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga00764af4bfa719981b2a4f6e224dd9c1a5b5b5381abb1f7b13e9f8bb3d1485d18"></a><!-- doxytag: member="TCC_RAMP_INDEX_FORCE_A" ref="gga00764af4bfa719981b2a4f6e224dd9c1a5b5b5381abb1f7b13e9f8bb3d1485d18" args="" -->TCC_RAMP_INDEX_FORCE_A</em>&nbsp;</td><td>
<p>Force next cycle to be cycle A (clear to 0). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga00764af4bfa719981b2a4f6e224dd9c1a5feec9212992528dcd589196f7a870e0"></a><!-- doxytag: member="TCC_RAMP_INDEX_FORCE_KEEP" ref="gga00764af4bfa719981b2a4f6e224dd9c1a5feec9212992528dcd589196f7a870e0" args="" -->TCC_RAMP_INDEX_FORCE_KEEP</em>&nbsp;</td><td>
<p>Force next cycle keeping the same as current. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga264546e2899d650a7028f6947dbac213"></a><!-- doxytag: member="tcc.h::tcc_reload_action" ref="ga264546e2899d650a7028f6947dbac213" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tcc__group.html#ga264546e2899d650a7028f6947dbac213">tcc_reload_action</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TCC Counter reload action enum. </p>
<p>This enum specify how the counter is reloaded and whether the prescaler should be restarted. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga264546e2899d650a7028f6947dbac213a670a06c074cc1472b0beca70288d4736"></a><!-- doxytag: member="TCC_RELOAD_ACTION_GCLK" ref="gga264546e2899d650a7028f6947dbac213a670a06c074cc1472b0beca70288d4736" args="" -->TCC_RELOAD_ACTION_GCLK</em>&nbsp;</td><td>
<p>The counter is reloaded/reset on the next GCLK and starts counting on the prescaler clock. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga264546e2899d650a7028f6947dbac213adb1a11b156b6046d7160867575b0ab07"></a><!-- doxytag: member="TCC_RELOAD_ACTION_PRESC" ref="gga264546e2899d650a7028f6947dbac213adb1a11b156b6046d7160867575b0ab07" args="" -->TCC_RELOAD_ACTION_PRESC</em>&nbsp;</td><td>
<p>The counter is reloaded/reset on the next prescaler clock. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga264546e2899d650a7028f6947dbac213a8428201f62b949440e8c63fe458e0fc0"></a><!-- doxytag: member="TCC_RELOAD_ACTION_RESYNC" ref="gga264546e2899d650a7028f6947dbac213a8428201f62b949440e8c63fe458e0fc0" args="" -->TCC_RELOAD_ACTION_RESYNC</em>&nbsp;</td><td>
<p>The counter is reloaded/reset on the next GCLK, and the prescaler is restarted as well. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga17089c430302f3def00bc4cfa2176c64"></a><!-- doxytag: member="tcc.h::tcc_wave_generation" ref="ga17089c430302f3def00bc4cfa2176c64" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tcc__group.html#ga17089c430302f3def00bc4cfa2176c64">tcc_wave_generation</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TCC wave generation mode enum. </p>
<p>This enum is used to specify the waveform generation mode. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga17089c430302f3def00bc4cfa2176c64adc633542224dc2dd60668814c200b856"></a><!-- doxytag: member="TCC_WAVE_GENERATION_NORMAL_FREQ" ref="gga17089c430302f3def00bc4cfa2176c64adc633542224dc2dd60668814c200b856" args="" -->TCC_WAVE_GENERATION_NORMAL_FREQ</em>&nbsp;</td><td>
<p>Normal Frequency: Top is the PER register, output toggled on each compare match. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga17089c430302f3def00bc4cfa2176c64a2b290ae1f45d8e342aad437bd1d9c9aa"></a><!-- doxytag: member="TCC_WAVE_GENERATION_MATCH_FREQ" ref="gga17089c430302f3def00bc4cfa2176c64a2b290ae1f45d8e342aad437bd1d9c9aa" args="" -->TCC_WAVE_GENERATION_MATCH_FREQ</em>&nbsp;</td><td>
<p>Match Frequency: Top is CC0 register, output toggles on each update condition. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga17089c430302f3def00bc4cfa2176c64a410425079bb54c0cce5f385ff01e66dc"></a><!-- doxytag: member="TCC_WAVE_GENERATION_SINGLE_SLOPE_PWM" ref="gga17089c430302f3def00bc4cfa2176c64a410425079bb54c0cce5f385ff01e66dc" args="" -->TCC_WAVE_GENERATION_SINGLE_SLOPE_PWM</em>&nbsp;</td><td>
<p>Single-Slope PWM: Top is the PER register, CCx controls duty cycle ( output active when count is greater than CCx). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga17089c430302f3def00bc4cfa2176c64add7608a724c8c655a6338749e9259152"></a><!-- doxytag: member="TCC_WAVE_GENERATION_DOUBLE_SLOPE_CRITICAL" ref="gga17089c430302f3def00bc4cfa2176c64add7608a724c8c655a6338749e9259152" args="" -->TCC_WAVE_GENERATION_DOUBLE_SLOPE_CRITICAL</em>&nbsp;</td><td>
<p>Double-slope (count up and down), non centre-aligned: Top is the PER register, CC[x] controls duty cycle while counting up and CC[x+N/2] controls it while counting down. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga17089c430302f3def00bc4cfa2176c64aec68f47d4983be9e906e1311f8dd59f1"></a><!-- doxytag: member="TCC_WAVE_GENERATION_DOUBLE_SLOPE_BOTTOM" ref="gga17089c430302f3def00bc4cfa2176c64aec68f47d4983be9e906e1311f8dd59f1" args="" -->TCC_WAVE_GENERATION_DOUBLE_SLOPE_BOTTOM</em>&nbsp;</td><td>
<p>Double-slope (count up and down), interrupt/event at Bottom (Top is the PER register, output active when count is greater than CCx). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga17089c430302f3def00bc4cfa2176c64ad6b23beb050085088c72b5fd81c43e96"></a><!-- doxytag: member="TCC_WAVE_GENERATION_DOUBLE_SLOPE_BOTH" ref="gga17089c430302f3def00bc4cfa2176c64ad6b23beb050085088c72b5fd81c43e96" args="" -->TCC_WAVE_GENERATION_DOUBLE_SLOPE_BOTH</em>&nbsp;</td><td>
<p>Double-slope (count up and down), interrupt/event at Bottom and Top: (Top is the PER register, output active when count is lower than CCx). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga17089c430302f3def00bc4cfa2176c64a92f114fb43174f1b917757808fa634b8"></a><!-- doxytag: member="TCC_WAVE_GENERATION_DOUBLE_SLOPE_TOP" ref="gga17089c430302f3def00bc4cfa2176c64a92f114fb43174f1b917757808fa634b8" args="" -->TCC_WAVE_GENERATION_DOUBLE_SLOPE_TOP</em>&nbsp;</td><td>
<p>Double-slope (count up and down), interrupt/event at Top (Top is the PER register, output active when count is greater than CCx). </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga94e085112cc19e5704a40ac7f339b93e"></a><!-- doxytag: member="tcc.h::tcc_wave_output" ref="ga94e085112cc19e5704a40ac7f339b93e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tcc__group.html#ga94e085112cc19e5704a40ac7f339b93e">tcc_wave_output</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Index of the wave outputs. </p>
<p>This enum is used to specify which wave output to do operations on. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga94e085112cc19e5704a40ac7f339b93ea27b309a1d5d9b4068806365d900b839c"></a><!-- doxytag: member="TCC_WAVE_OUTPUT_N" ref="gga94e085112cc19e5704a40ac7f339b93ea27b309a1d5d9b4068806365d900b839c" args="" -->TCC_WAVE_OUTPUT_N</em>&nbsp;</td><td>
<p>Indexes of match capture channels, e.g., TCC_WAVEFORM_OUTPUT_0. Number of supported channels. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga30b821497239e10c9d05d457517ae660"></a><!-- doxytag: member="tcc.h::tcc_wave_polarity" ref="ga30b821497239e10c9d05d457517ae660" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tcc__group.html#ga30b821497239e10c9d05d457517ae660">tcc_wave_polarity</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Polarity of TCC wave generation on channels. </p>
<p>Specifies whether the wave output needs to be inverted or not. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga30b821497239e10c9d05d457517ae660a86b9b44a2c9e6629f23c6cba7ca9dd66"></a><!-- doxytag: member="TCC_WAVE_POLARITY_0" ref="gga30b821497239e10c9d05d457517ae660a86b9b44a2c9e6629f23c6cba7ca9dd66" args="" -->TCC_WAVE_POLARITY_0</em>&nbsp;</td><td>
<p>Wave output is not inverted. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga30b821497239e10c9d05d457517ae660a1a1df87b86653af7e20451f66d12b072"></a><!-- doxytag: member="TCC_WAVE_POLARITY_1" ref="gga30b821497239e10c9d05d457517ae660a1a1df87b86653af7e20451f66d12b072" args="" -->TCC_WAVE_POLARITY_1</em>&nbsp;</td><td>
<p>Wave output is inverted. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu Jun 23 2016 20:43:14 for Atmel Radio by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
